{"version":3,"sources":["webpack:///profile.56fab56f950907c5b67a.bundle.js","webpack:///./profile/profile_bundle.js","webpack:///./profile/gl_crop.js","webpack:////var/cache/omnibus/src/gitlab-rails/vendor/assets/javascripts/cropper.js","webpack:///./profile/profile.js"],"names":["webpackJsonp","RUZQ","module","exports","__webpack_require__","Yig8","__webpack_exports__","$","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_vendor_cropper__","_createClass","n","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","global","GitLabCrop","input","_ref","arguments","undefined","filename","previewImage","modalCrop","pickImageEl","uploadImageBtn","modalCropImg","_ref$exportWidth","exportWidth","_ref$exportHeight","exportHeight","_ref$cropBoxWidth","cropBoxWidth","_ref$cropBoxHeight","cropBoxHeight","this","onUploadImageBtnClick","bind","onModalHide","onModalShow","onPickImageClick","fileInput","_","isString","attr","form","parents","getElement","cropActionsBtn","find","bindEvents","selector","_this","on","e","onFileInputChange","btn","onActionBtnClick","croppedImageBlob","trigger","cropper","viewMode","center","aspectRatio","modal","scalable","rotatable","zoomable","dragMode","guides","zoomOnTouch","zoomOnWheel","cropBoxMovable","cropBoxResizable","toggleDragModeOnDblclick","built","$image","container","width","height","left","top","preventDefault","setBlob","setPreview","val","data","method","option","readFile","reader","FileReader","onload","result","readAsDataURL","files","dataURL","array","binary","k","len","atob","split","push","charCodeAt","Blob","Uint8Array","type","replace","text","toDataURL","dataURLtoBlob","fn","glCrop","opts","each","window","gl","call","aX1M","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","apply","isNumber","isNaN","isUndefined","toArray","obj","offset","args","slice","proxy","context","concat","isCrossOriginURL","url","parts","match","location","protocol","hostname","port","addTimestamp","timestamp","Date","getTime","indexOf","getCrossOrigin","crossOrigin","getImageSize","image","callback","newImage","naturalWidth","IS_SAFARI","naturalHeight","document","createElement","src","getTransform","options","transforms","rotate","scaleX","scaleY","join","getRotatedSizes","isReversed","newWidth","newHeight","deg","abs","degree","arc","Math","PI","sinArc","sin","cosArc","cos","getSourceCanvas","translateX","translateY","rotated","canvas","getContext","dstX","dstY","dstWidth","dstHeight","advanced","canvasWidth","canvasHeight","save","translate","scale","drawImage","floor","restore","getTouchesCenter","touches","pageX","pageY","touch","getStringFromCharCode","dataView","start","str","fromCharCode","getUint8","getOrientation","arrayBuffer","orientation","exifIDCode","tiffOffset","firstIFDOffset","littleEndian","endianness","app1Start","ifdStart","DataView","byteLength","getUint16","getUint32","setUint16","dataURLToArrayBuffer","base64","REGEXP_DATA_URL_HEAD","ArrayBuffer","arrayBufferToDataURL","btoa","Cropper","element","$element","extend","DEFAULTS","isPlainObject","isLoaded","isBuilt","isCompleted","isRotated","isCropped","isDisabled","isReplaced","isLimited","wheeling","isImg","originalUrl","cropBox","init","$window","$document","navigator","CLASS_HIDDEN","EVENT_MOUSE_UP","REGEXP_ACTIONS","REGEXP_DATA_URL","REGEXP_DATA_URL_JPEG","SUPPORT_CANVAS","isFunction","test","userAgent","vendor","num","Number","min","max","sqrt","round","String","constructor","$this","is","prop","load","Event","read","xhr","one","build","isDefaultPrevented","checkOrientation","clone","XMLHttpRequest","onerror","onabort","response","open","responseType","send","crossOriginUrl","$clone","checkCrossOrigin","complete","stop","addClass","insertAfter","off","remove","$cropper","$cropBox","$face","unbuild","$container","parent","TEMPLATE","$canvas","append","$dragBox","$viewBox","after","removeClass","initPreview","NaN","autoCrop","highlight","background","setDragMode","render","setData","setTimeout","initialImage","initialCanvas","initialCropBox","unbind","resetPreview","$preview","initContainer","initCanvas","initCropBox","renderCanvas","renderCropBox","css","minContainerWidth","minContainerHeight","containerWidth","containerHeight","imageNaturalWidth","imageNaturalHeight","is90Degree","oldLeft","oldTop","limitCanvas","isSizeLimited","isPositionLimited","minCanvasWidth","minCanvasHeight","newCanvasLeft","newCanvasTop","minWidth","minHeight","maxWidth","Infinity","maxHeight","minLeft","minTop","maxLeft","maxTop","isChanged","renderImage","limitCropBox","output","reversed","marginLeft","marginTop","transform","autoCropArea","minCropBoxWidth","minCropBoxHeight","maxCropBoxWidth","maxCropBoxHeight","movable","preview","getData","$clone2","html","removeData","originalWidth","originalHeight","ratio","cropstart","cropmove","cropend","crop","zoom","cropStart","wheel","dblclick","_cropMove","cropMove","_cropEnd","cropEnd","responsive","_resize","resize","canvasData","cropBoxData","getCanvasData","getCropBoxData","setCanvasData","setCropBoxData","hasClass","event","originalEvent","wheelZoomRatio","delta","deltaY","wheelDelta","detail","touchesLength","action","startX2","startY2","cropping","startX","startY","endX2","endY2","endX","endY","change","shiftKey","toggleClass","range","right","bottom","renderable","limited","x","y","X","Y","move","x1","y1","x2","y2","z1","reset","clear","onlyColorChanged","add","enable","disable","destroy","offsetX","offsetY","moveTo","_event","zoomTo","oldRatio","rotateTo","isRounded","isScaled","getContainerData","getImageData","isWidthChanged","isHeightChanged","getCroppedCanvas","scaledWidth","scaledHeight","scaledRatio","fillColor","fillStyle","fillRect","srcWidth","srcHeight","source","sourceWidth","sourceHeight","params","srcX","srcY","setAspectRatio","mode","croppable","setDefaults","other","noConflict","dYvO","Profile","onSubmitForm","initAvatarGlCrop","cropOpts","avatarGlCrop","submitForm","beforeUpdateUsername","afterUpdateUsername","onUpdateNotifs","submit","saveForm","saved","Flash","self","formData","FormData","avatarBlob","getBlob","ajax","dataType","processData","contentType","success","message","error","jqXHR","responseJSON","scrollTo","$title","comment","utils","getPagePath"],"mappings":"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","file":"profile.56fab56f950907c5b67a.bundle.js","sourcesContent":["webpackJsonp([23],{\n\n/***/ \"RUZQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"Yig8\");\n__webpack_require__(\"dYvO\");\n\n/***/ }),\n\n/***/ \"Yig8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function($) {Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_cropper__ = __webpack_require__(\"aX1M\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_cropper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vendor_cropper__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable no-useless-escape, max-len, quotes, no-var, no-underscore-dangle, func-names, space-before-function-paren, no-unused-vars, no-return-assign, object-shorthand, one-var, one-var-declaration-per-line, comma-dangle, consistent-return, class-methods-use-this, new-parens */\n\n\n\n(function (global) {\n  // Matches everything but the file name\n  var FILENAMEREGEX = /^.*[\\\\\\/]/;\n\n  var GitLabCrop = function () {\n    function GitLabCrop(input) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          filename = _ref.filename,\n          previewImage = _ref.previewImage,\n          modalCrop = _ref.modalCrop,\n          pickImageEl = _ref.pickImageEl,\n          uploadImageBtn = _ref.uploadImageBtn,\n          modalCropImg = _ref.modalCropImg,\n          _ref$exportWidth = _ref.exportWidth,\n          exportWidth = _ref$exportWidth === undefined ? 200 : _ref$exportWidth,\n          _ref$exportHeight = _ref.exportHeight,\n          exportHeight = _ref$exportHeight === undefined ? 200 : _ref$exportHeight,\n          _ref$cropBoxWidth = _ref.cropBoxWidth,\n          cropBoxWidth = _ref$cropBoxWidth === undefined ? 200 : _ref$cropBoxWidth,\n          _ref$cropBoxHeight = _ref.cropBoxHeight,\n          cropBoxHeight = _ref$cropBoxHeight === undefined ? 200 : _ref$cropBoxHeight;\n\n      _classCallCheck(this, GitLabCrop);\n\n      this.onUploadImageBtnClick = this.onUploadImageBtnClick.bind(this);\n      this.onModalHide = this.onModalHide.bind(this);\n      this.onModalShow = this.onModalShow.bind(this);\n      this.onPickImageClick = this.onPickImageClick.bind(this);\n      this.fileInput = $(input);\n      this.modalCropImg = _.isString(this.modalCropImg) ? $(this.modalCropImg) : this.modalCropImg;\n      this.fileInput.attr('name', this.fileInput.attr('name') + '-trigger').attr('id', this.fileInput.attr('id') + '-trigger');\n      this.exportWidth = exportWidth;\n      this.exportHeight = exportHeight;\n      this.cropBoxWidth = cropBoxWidth;\n      this.cropBoxHeight = cropBoxHeight;\n      this.form = this.fileInput.parents('form');\n      this.filename = filename;\n      this.previewImage = previewImage;\n      this.modalCrop = modalCrop;\n      this.pickImageEl = pickImageEl;\n      this.uploadImageBtn = uploadImageBtn;\n      this.modalCropImg = modalCropImg;\n      this.filename = this.getElement(filename);\n      this.previewImage = this.getElement(previewImage);\n      this.pickImageEl = this.getElement(pickImageEl);\n      this.modalCrop = _.isString(modalCrop) ? $(modalCrop) : modalCrop;\n      this.uploadImageBtn = _.isString(uploadImageBtn) ? $(uploadImageBtn) : uploadImageBtn;\n      this.modalCropImg = _.isString(modalCropImg) ? $(modalCropImg) : modalCropImg;\n      this.cropActionsBtn = this.modalCrop.find('[data-method]');\n      this.bindEvents();\n    }\n\n    _createClass(GitLabCrop, [{\n      key: 'getElement',\n      value: function getElement(selector) {\n        return $(selector, this.form);\n      }\n    }, {\n      key: 'bindEvents',\n      value: function bindEvents() {\n        var _this;\n        _this = this;\n        this.fileInput.on('change', function (e) {\n          return _this.onFileInputChange(e, this);\n        });\n        this.pickImageEl.on('click', this.onPickImageClick);\n        this.modalCrop.on('shown.bs.modal', this.onModalShow);\n        this.modalCrop.on('hidden.bs.modal', this.onModalHide);\n        this.uploadImageBtn.on('click', this.onUploadImageBtnClick);\n        this.cropActionsBtn.on('click', function (e) {\n          var btn;\n          btn = this;\n          return _this.onActionBtnClick(btn);\n        });\n        return this.croppedImageBlob = null;\n      }\n    }, {\n      key: 'onPickImageClick',\n      value: function onPickImageClick() {\n        return this.fileInput.trigger('click');\n      }\n    }, {\n      key: 'onModalShow',\n      value: function onModalShow() {\n        var _this;\n        _this = this;\n        return this.modalCropImg.cropper({\n          viewMode: 1,\n          center: false,\n          aspectRatio: 1,\n          modal: true,\n          scalable: false,\n          rotatable: false,\n          zoomable: true,\n          dragMode: 'move',\n          guides: false,\n          zoomOnTouch: false,\n          zoomOnWheel: false,\n          cropBoxMovable: false,\n          cropBoxResizable: false,\n          toggleDragModeOnDblclick: false,\n          built: function built() {\n            var $image, container, cropBoxHeight, cropBoxWidth;\n            $image = $(this);\n            container = $image.cropper('getContainerData');\n            cropBoxWidth = _this.cropBoxWidth;\n            cropBoxHeight = _this.cropBoxHeight;\n            return $image.cropper('setCropBoxData', {\n              width: cropBoxWidth,\n              height: cropBoxHeight,\n              left: (container.width - cropBoxWidth) / 2,\n              top: (container.height - cropBoxHeight) / 2\n            });\n          }\n        });\n      }\n    }, {\n      key: 'onModalHide',\n      value: function onModalHide() {\n        return this.modalCropImg.attr('src', '').cropper('destroy');\n      }\n    }, {\n      key: 'onUploadImageBtnClick',\n      value: function onUploadImageBtnClick(e) {\n        e.preventDefault();\n        this.setBlob();\n        this.setPreview();\n        this.modalCrop.modal('hide');\n        return this.fileInput.val('');\n      }\n    }, {\n      key: 'onActionBtnClick',\n      value: function onActionBtnClick(btn) {\n        var data, result;\n        data = $(btn).data();\n        if (this.modalCropImg.data('cropper') && data.method) {\n          return result = this.modalCropImg.cropper(data.method, data.option);\n        }\n      }\n    }, {\n      key: 'onFileInputChange',\n      value: function onFileInputChange(e, input) {\n        return this.readFile(input);\n      }\n    }, {\n      key: 'readFile',\n      value: function readFile(input) {\n        var _this, reader;\n        _this = this;\n        reader = new FileReader();\n        reader.onload = function () {\n          _this.modalCropImg.attr('src', reader.result);\n          return _this.modalCrop.modal('show');\n        };\n        return reader.readAsDataURL(input.files[0]);\n      }\n    }, {\n      key: 'dataURLtoBlob',\n      value: function dataURLtoBlob(dataURL) {\n        var array, binary, i, k, len, v;\n        binary = atob(dataURL.split(',')[1]);\n        array = [];\n        for (k = i = 0, len = binary.length; i < len; k = i += 1) {\n          v = binary[k];\n          array.push(binary.charCodeAt(k));\n        }\n        return new Blob([new Uint8Array(array)], {\n          type: 'image/png'\n        });\n      }\n    }, {\n      key: 'setPreview',\n      value: function setPreview() {\n        var filename;\n        this.previewImage.attr('src', this.dataURL);\n        filename = this.fileInput.val().replace(FILENAMEREGEX, '');\n        return this.filename.text(filename);\n      }\n    }, {\n      key: 'setBlob',\n      value: function setBlob() {\n        this.dataURL = this.modalCropImg.cropper('getCroppedCanvas', {\n          width: 200,\n          height: 200\n        }).toDataURL('image/png');\n        return this.croppedImageBlob = this.dataURLtoBlob(this.dataURL);\n      }\n    }, {\n      key: 'getBlob',\n      value: function getBlob() {\n        return this.croppedImageBlob;\n      }\n    }]);\n\n    return GitLabCrop;\n  }();\n\n  $.fn.glCrop = function (opts) {\n    return this.each(function () {\n      return $(this).data('glcrop', new GitLabCrop(this, opts));\n    });\n  };\n})(window.gl || (window.gl = {}));\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(\"lwLq\")))\n\n/***/ }),\n\n/***/ \"aX1M\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Cropper v2.3.0\n * https://github.com/fengyuanchen/cropper\n *\n * Copyright (c) 2014-2016 Fengyuan Chen and contributors\n * Released under the MIT license\n *\n * Date: 2016-02-22T02:13:13.332Z\n */\n\n(function (factory) {\n  if (true) {\n    // AMD. Register as anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"lwLq\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports === 'object') {\n    // Node / CommonJS\n    factory(require('jquery'));\n  } else {\n    // Browser globals.\n    factory(jQuery);\n  }\n})(function ($) {\n\n  'use strict';\n\n  // Globals\n  var $window = $(window);\n  var $document = $(document);\n  var location = window.location;\n  var navigator = window.navigator;\n  var ArrayBuffer = window.ArrayBuffer;\n  var Uint8Array = window.Uint8Array;\n  var DataView = window.DataView;\n  var btoa = window.btoa;\n\n  // Constants\n  var NAMESPACE = 'cropper';\n\n  // Classes\n  var CLASS_MODAL = 'cropper-modal';\n  var CLASS_HIDE = 'cropper-hide';\n  var CLASS_HIDDEN = 'cropper-hidden';\n  var CLASS_INVISIBLE = 'cropper-invisible';\n  var CLASS_MOVE = 'cropper-move';\n  var CLASS_CROP = 'cropper-crop';\n  var CLASS_DISABLED = 'cropper-disabled';\n  var CLASS_BG = 'cropper-bg';\n\n  // Events\n  var EVENT_MOUSE_DOWN = 'mousedown touchstart pointerdown MSPointerDown';\n  var EVENT_MOUSE_MOVE = 'mousemove touchmove pointermove MSPointerMove';\n  var EVENT_MOUSE_UP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';\n  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_LOAD = 'load.' + NAMESPACE;\n  var EVENT_ERROR = 'error.' + NAMESPACE;\n  var EVENT_RESIZE = 'resize.' + NAMESPACE; // Bind to window with namespace\n  var EVENT_BUILD = 'build.' + NAMESPACE;\n  var EVENT_BUILT = 'built.' + NAMESPACE;\n  var EVENT_CROP_START = 'cropstart.' + NAMESPACE;\n  var EVENT_CROP_MOVE = 'cropmove.' + NAMESPACE;\n  var EVENT_CROP_END = 'cropend.' + NAMESPACE;\n  var EVENT_CROP = 'crop.' + NAMESPACE;\n  var EVENT_ZOOM = 'zoom.' + NAMESPACE;\n\n  // RegExps\n  var REGEXP_ACTIONS = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/;\n  var REGEXP_DATA_URL = /^data\\:/;\n  var REGEXP_DATA_URL_HEAD = /^data\\:([^\\;]+)\\;base64,/;\n  var REGEXP_DATA_URL_JPEG = /^data\\:image\\/jpeg.*;base64,/;\n\n  // Data keys\n  var DATA_PREVIEW = 'preview';\n  var DATA_ACTION = 'action';\n\n  // Actions\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_NONE = 'none';\n\n  // Supports\n  var SUPPORT_CANVAS = $.isFunction($('<canvas>')[0].getContext);\n  var IS_SAFARI = navigator && /safari/i.test(navigator.userAgent) && /apple computer/i.test(navigator.vendor);\n\n  // Maths\n  var num = Number;\n  var min = Math.min;\n  var max = Math.max;\n  var abs = Math.abs;\n  var sin = Math.sin;\n  var cos = Math.cos;\n  var sqrt = Math.sqrt;\n  var round = Math.round;\n  var floor = Math.floor;\n\n  // Utilities\n  var fromCharCode = String.fromCharCode;\n\n  function isNumber(n) {\n    return typeof n === 'number' && !isNaN(n);\n  }\n\n  function isUndefined(n) {\n    return typeof n === 'undefined';\n  }\n\n  function toArray(obj, offset) {\n    var args = [];\n\n    // This is necessary for IE8\n    if (isNumber(offset)) {\n      args.push(offset);\n    }\n\n    return args.slice.apply(obj, args);\n  }\n\n  // Custom proxy to avoid jQuery's guid\n  function proxy(fn, context) {\n    var args = toArray(arguments, 2);\n\n    return function () {\n      return fn.apply(context, args.concat(toArray(arguments)));\n    };\n  }\n\n  function isCrossOriginURL(url) {\n    var parts = url.match(/^(https?:)\\/\\/([^\\:\\/\\?#]+):?(\\d*)/i);\n\n    return parts && (\n      parts[1] !== location.protocol ||\n      parts[2] !== location.hostname ||\n      parts[3] !== location.port\n    );\n  }\n\n  function addTimestamp(url) {\n    var timestamp = 'timestamp=' + (new Date()).getTime();\n\n    return (url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp);\n  }\n\n  function getCrossOrigin(crossOrigin) {\n    return crossOrigin ? ' crossOrigin=\"' + crossOrigin + '\"' : '';\n  }\n\n  function getImageSize(image, callback) {\n    var newImage;\n\n    // Modern browsers (ignore Safari, #120 & #509)\n    if (image.naturalWidth && !IS_SAFARI) {\n      return callback(image.naturalWidth, image.naturalHeight);\n    }\n\n    // IE8: Don't use `new Image()` here (#319)\n    newImage = document.createElement('img');\n\n    newImage.onload = function () {\n      callback(this.width, this.height);\n    };\n\n    newImage.src = image.src;\n  }\n\n  function getTransform(options) {\n    var transforms = [];\n    var rotate = options.rotate;\n    var scaleX = options.scaleX;\n    var scaleY = options.scaleY;\n\n    if (isNumber(rotate)) {\n      transforms.push('rotate(' + rotate + 'deg)');\n    }\n\n    if (isNumber(scaleX) && isNumber(scaleY)) {\n      transforms.push('scale(' + scaleX + ',' + scaleY + ')');\n    }\n\n    return transforms.length ? transforms.join(' ') : 'none';\n  }\n\n  function getRotatedSizes(data, isReversed) {\n    var deg = abs(data.degree) % 180;\n    var arc = (deg > 90 ? (180 - deg) : deg) * Math.PI / 180;\n    var sinArc = sin(arc);\n    var cosArc = cos(arc);\n    var width = data.width;\n    var height = data.height;\n    var aspectRatio = data.aspectRatio;\n    var newWidth;\n    var newHeight;\n\n    if (!isReversed) {\n      newWidth = width * cosArc + height * sinArc;\n      newHeight = width * sinArc + height * cosArc;\n    } else {\n      newWidth = width / (cosArc + sinArc / aspectRatio);\n      newHeight = newWidth / aspectRatio;\n    }\n\n    return {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  function getSourceCanvas(image, data) {\n    var canvas = $('<canvas>')[0];\n    var context = canvas.getContext('2d');\n    var dstX = 0;\n    var dstY = 0;\n    var dstWidth = data.naturalWidth;\n    var dstHeight = data.naturalHeight;\n    var rotate = data.rotate;\n    var scaleX = data.scaleX;\n    var scaleY = data.scaleY;\n    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);\n    var rotatable = isNumber(rotate) && rotate !== 0;\n    var advanced = rotatable || scalable;\n    var canvasWidth = dstWidth * abs(scaleX || 1);\n    var canvasHeight = dstHeight * abs(scaleY || 1);\n    var translateX;\n    var translateY;\n    var rotated;\n\n    if (scalable) {\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    if (rotatable) {\n      rotated = getRotatedSizes({\n        width: canvasWidth,\n        height: canvasHeight,\n        degree: rotate\n      });\n\n      canvasWidth = rotated.width;\n      canvasHeight = rotated.height;\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    if (advanced) {\n      dstX = -dstWidth / 2;\n      dstY = -dstHeight / 2;\n\n      context.save();\n      context.translate(translateX, translateY);\n    }\n\n    if (rotatable) {\n      context.rotate(rotate * Math.PI / 180);\n    }\n\n    // Should call `scale` after rotated\n    if (scalable) {\n      context.scale(scaleX, scaleY);\n    }\n\n    context.drawImage(image, floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n\n    if (advanced) {\n      context.restore();\n    }\n\n    return canvas;\n  }\n\n  function getTouchesCenter(touches) {\n    var length = touches.length;\n    var pageX = 0;\n    var pageY = 0;\n\n    if (length) {\n      $.each(touches, function (i, touch) {\n        pageX += touch.pageX;\n        pageY += touch.pageY;\n      });\n\n      pageX /= length;\n      pageY /= length;\n    }\n\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    var i;\n\n    for (i = start, length += start; i < length; i++) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n\n    return str;\n  }\n\n  function getOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var length = dataView.byteLength;\n    var orientation;\n    var exifIDCode;\n    var tiffOffset;\n    var firstIFDOffset;\n    var littleEndian;\n    var endianness;\n    var app1Start;\n    var ifdStart;\n    var offset;\n    var i;\n\n    // Only handle JPEG image (start by 0xFFD8)\n    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n      offset = 2;\n\n      while (offset < length) {\n        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n          app1Start = offset;\n          break;\n        }\n\n        offset++;\n      }\n    }\n\n    if (app1Start) {\n      exifIDCode = app1Start + 4;\n      tiffOffset = app1Start + 10;\n\n      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n        endianness = dataView.getUint16(tiffOffset);\n        littleEndian = endianness === 0x4949;\n\n        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n      }\n    }\n\n    if (ifdStart) {\n      length = dataView.getUint16(ifdStart, littleEndian);\n\n      for (i = 0; i < length; i++) {\n        offset = ifdStart + i * 12 + 2;\n\n        if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {\n\n          // 8 is the offset of the current tag's value\n          offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(offset, littleEndian);\n\n          // Override the orientation with its default value for Safari (#120)\n          if (IS_SAFARI) {\n            dataView.setUint16(offset, 1, littleEndian);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return orientation;\n  }\n\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var length = binary.length;\n    var arrayBuffer = new ArrayBuffer(length);\n    var dataView = new Uint8Array(arrayBuffer);\n    var i;\n\n    for (i = 0; i < length; i++) {\n      dataView[i] = binary.charCodeAt(i);\n    }\n\n    return arrayBuffer;\n  }\n\n  // Only available for JPEG image\n  function arrayBufferToDataURL(arrayBuffer) {\n    var dataView = new Uint8Array(arrayBuffer);\n    var length = dataView.length;\n    var base64 = '';\n    var i;\n\n    for (i = 0; i < length; i++) {\n      base64 += fromCharCode(dataView[i]);\n    }\n\n    return 'data:image/jpeg;base64,' + btoa(base64);\n  }\n\n  function Cropper(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, Cropper.DEFAULTS, $.isPlainObject(options) && options);\n    this.isLoaded = false;\n    this.isBuilt = false;\n    this.isCompleted = false;\n    this.isRotated = false;\n    this.isCropped = false;\n    this.isDisabled = false;\n    this.isReplaced = false;\n    this.isLimited = false;\n    this.wheeling = false;\n    this.isImg = false;\n    this.originalUrl = '';\n    this.canvas = null;\n    this.cropBox = null;\n    this.init();\n  }\n\n  Cropper.prototype = {\n    constructor: Cropper,\n\n    init: function () {\n      var $this = this.$element;\n      var url;\n\n      if ($this.is('img')) {\n        this.isImg = true;\n\n        // Should use `$.fn.attr` here. e.g.: \"img/picture.jpg\"\n        this.originalUrl = url = $this.attr('src');\n\n        // Stop when it's a blank image\n        if (!url) {\n          return;\n        }\n\n        // Should use `$.fn.prop` here. e.g.: \"http://example.com/img/picture.jpg\"\n        url = $this.prop('src');\n      } else if ($this.is('canvas') && SUPPORT_CANVAS) {\n        url = $this[0].toDataURL();\n      }\n\n      this.load(url);\n    },\n\n    // A shortcut for triggering custom events\n    trigger: function (type, data) {\n      var e = $.Event(type, data);\n\n      this.$element.trigger(e);\n\n      return e;\n    },\n\n    load: function (url) {\n      var options = this.options;\n      var $this = this.$element;\n      var read;\n      var xhr;\n\n      if (!url) {\n        return;\n      }\n\n      // Trigger build event first\n      $this.one(EVENT_BUILD, options.build);\n\n      if (this.trigger(EVENT_BUILD).isDefaultPrevented()) {\n        return;\n      }\n\n      this.url = url;\n      this.image = {};\n\n      if (!options.checkOrientation || !ArrayBuffer) {\n        return this.clone();\n      }\n\n      read = $.proxy(this.read, this);\n\n      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari\n      if (REGEXP_DATA_URL.test(url)) {\n        return REGEXP_DATA_URL_JPEG.test(url) ?\n          read(dataURLToArrayBuffer(url)) :\n          this.clone();\n      }\n\n      xhr = new XMLHttpRequest();\n\n      xhr.onerror = xhr.onabort = $.proxy(function () {\n        this.clone();\n      }, this);\n\n      xhr.onload = function () {\n        read(this.response);\n      };\n\n      xhr.open('get', url);\n      xhr.responseType = 'arraybuffer';\n      xhr.send();\n    },\n\n    read: function (arrayBuffer) {\n      var options = this.options;\n      var orientation = getOrientation(arrayBuffer);\n      var image = this.image;\n      var rotate;\n      var scaleX;\n      var scaleY;\n\n      if (orientation > 1) {\n        this.url = arrayBufferToDataURL(arrayBuffer);\n\n        switch (orientation) {\n\n          // flip horizontal\n          case 2:\n            scaleX = -1;\n            break;\n\n          // rotate left 180°\n          case 3:\n            rotate = -180;\n            break;\n\n          // flip vertical\n          case 4:\n            scaleY = -1;\n            break;\n\n          // flip vertical + rotate right 90°\n          case 5:\n            rotate = 90;\n            scaleY = -1;\n            break;\n\n          // rotate right 90°\n          case 6:\n            rotate = 90;\n            break;\n\n          // flip horizontal + rotate right 90°\n          case 7:\n            rotate = 90;\n            scaleX = -1;\n            break;\n\n          // rotate left 90°\n          case 8:\n            rotate = -90;\n            break;\n        }\n      }\n\n      if (options.rotatable) {\n        image.rotate = rotate;\n      }\n\n      if (options.scalable) {\n        image.scaleX = scaleX;\n        image.scaleY = scaleY;\n      }\n\n      this.clone();\n    },\n\n    clone: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var url = this.url;\n      var crossOrigin = '';\n      var crossOriginUrl;\n      var $clone;\n\n      if (options.checkCrossOrigin && isCrossOriginURL(url)) {\n        crossOrigin = $this.prop('crossOrigin');\n\n        if (crossOrigin) {\n          crossOriginUrl = url;\n        } else {\n          crossOrigin = 'anonymous';\n\n          // Bust cache (#148) when there is not a \"crossOrigin\" property\n          crossOriginUrl = addTimestamp(url);\n        }\n      }\n\n      this.crossOrigin = crossOrigin;\n      this.crossOriginUrl = crossOriginUrl;\n      this.$clone = $clone = $('<img' + getCrossOrigin(crossOrigin) + ' src=\"' + (crossOriginUrl || url) + '\">');\n\n      if (this.isImg) {\n        if ($this[0].complete) {\n          this.start();\n        } else {\n          $this.one(EVENT_LOAD, $.proxy(this.start, this));\n        }\n      } else {\n        $clone.\n          one(EVENT_LOAD, $.proxy(this.start, this)).\n          one(EVENT_ERROR, $.proxy(this.stop, this)).\n          addClass(CLASS_HIDE).\n          insertAfter($this);\n      }\n    },\n\n    start: function () {\n      var $image = this.$element;\n      var $clone = this.$clone;\n\n      if (!this.isImg) {\n        $clone.off(EVENT_ERROR, this.stop);\n        $image = $clone;\n      }\n\n      getImageSize($image[0], $.proxy(function (naturalWidth, naturalHeight) {\n        $.extend(this.image, {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight,\n          aspectRatio: naturalWidth / naturalHeight\n        });\n\n        this.isLoaded = true;\n        this.build();\n      }, this));\n    },\n\n    stop: function () {\n      this.$clone.remove();\n      this.$clone = null;\n    },\n\n    build: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $clone = this.$clone;\n      var $cropper;\n      var $cropBox;\n      var $face;\n\n      if (!this.isLoaded) {\n        return;\n      }\n\n      // Unbuild first when replace\n      if (this.isBuilt) {\n        this.unbuild();\n      }\n\n      // Create cropper elements\n      this.$container = $this.parent();\n      this.$cropper = $cropper = $(Cropper.TEMPLATE);\n      this.$canvas = $cropper.find('.cropper-canvas').append($clone);\n      this.$dragBox = $cropper.find('.cropper-drag-box');\n      this.$cropBox = $cropBox = $cropper.find('.cropper-crop-box');\n      this.$viewBox = $cropper.find('.cropper-view-box');\n      this.$face = $face = $cropBox.find('.cropper-face');\n\n      // Hide the original image\n      $this.addClass(CLASS_HIDDEN).after($cropper);\n\n      // Show the clone image if is hidden\n      if (!this.isImg) {\n        $clone.removeClass(CLASS_HIDE);\n      }\n\n      this.initPreview();\n      this.bind();\n\n      options.aspectRatio = max(0, options.aspectRatio) || NaN;\n      options.viewMode = max(0, min(3, round(options.viewMode))) || 0;\n\n      if (options.autoCrop) {\n        this.isCropped = true;\n\n        if (options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      } else {\n        $cropBox.addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.guides) {\n        $cropBox.find('.cropper-dashed').addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.center) {\n        $cropBox.find('.cropper-center').addClass(CLASS_HIDDEN);\n      }\n\n      if (options.cropBoxMovable) {\n        $face.addClass(CLASS_MOVE).data(DATA_ACTION, ACTION_ALL);\n      }\n\n      if (!options.highlight) {\n        $face.addClass(CLASS_INVISIBLE);\n      }\n\n      if (options.background) {\n        $cropper.addClass(CLASS_BG);\n      }\n\n      if (!options.cropBoxResizable) {\n        $cropBox.find('.cropper-line, .cropper-point').addClass(CLASS_HIDDEN);\n      }\n\n      this.setDragMode(options.dragMode);\n      this.render();\n      this.isBuilt = true;\n      this.setData(options.data);\n      $this.one(EVENT_BUILT, options.built);\n\n      // Trigger the built event asynchronously to keep `data('cropper')` is defined\n      setTimeout($.proxy(function () {\n        this.trigger(EVENT_BUILT);\n        this.isCompleted = true;\n      }, this), 0);\n    },\n\n    unbuild: function () {\n      if (!this.isBuilt) {\n        return;\n      }\n\n      this.isBuilt = false;\n      this.isCompleted = false;\n      this.initialImage = null;\n\n      // Clear `initialCanvas` is necessary when replace\n      this.initialCanvas = null;\n      this.initialCropBox = null;\n      this.container = null;\n      this.canvas = null;\n\n      // Clear `cropBox` is necessary when replace\n      this.cropBox = null;\n      this.unbind();\n\n      this.resetPreview();\n      this.$preview = null;\n\n      this.$viewBox = null;\n      this.$cropBox = null;\n      this.$dragBox = null;\n      this.$canvas = null;\n      this.$container = null;\n\n      this.$cropper.remove();\n      this.$cropper = null;\n    },\n\n    render: function () {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    initContainer: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $container = this.$container;\n      var $cropper = this.$cropper;\n\n      $cropper.addClass(CLASS_HIDDEN);\n      $this.removeClass(CLASS_HIDDEN);\n\n      $cropper.css((this.container = {\n        width: max($container.width(), num(options.minContainerWidth) || 200),\n        height: max($container.height(), num(options.minContainerHeight) || 100)\n      }));\n\n      $this.addClass(CLASS_HIDDEN);\n      $cropper.removeClass(CLASS_HIDDEN);\n    },\n\n    // Canvas (image wrapper)\n    initCanvas: function () {\n      var viewMode = this.options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var image = this.image;\n      var imageNaturalWidth = image.naturalWidth;\n      var imageNaturalHeight = image.naturalHeight;\n      var is90Degree = abs(image.rotate) === 90;\n      var naturalWidth = is90Degree ? imageNaturalHeight : imageNaturalWidth;\n      var naturalHeight = is90Degree ? imageNaturalWidth : imageNaturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerWidth;\n      var canvasHeight = containerHeight;\n      var canvas;\n\n      if (containerHeight * aspectRatio > containerWidth) {\n        if (viewMode === 3) {\n          canvasWidth = containerHeight * aspectRatio;\n        } else {\n          canvasHeight = containerWidth / aspectRatio;\n        }\n      } else {\n        if (viewMode === 3) {\n          canvasHeight = containerWidth / aspectRatio;\n        } else {\n          canvasWidth = containerHeight * aspectRatio;\n        }\n      }\n\n      canvas = {\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        aspectRatio: aspectRatio,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n\n      canvas.oldLeft = canvas.left = (containerWidth - canvasWidth) / 2;\n      canvas.oldTop = canvas.top = (containerHeight - canvasHeight) / 2;\n\n      this.canvas = canvas;\n      this.isLimited = (viewMode === 1 || viewMode === 2);\n      this.limitCanvas(true, true);\n      this.initialImage = $.extend({}, image);\n      this.initialCanvas = $.extend({}, canvas);\n    },\n\n    limitCanvas: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var viewMode = options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n      var cropBox = this.cropBox;\n      var isCropped = this.isCropped && cropBox;\n      var minCanvasWidth;\n      var minCanvasHeight;\n      var newCanvasLeft;\n      var newCanvasTop;\n\n      if (isSizeLimited) {\n        minCanvasWidth = num(options.minCanvasWidth) || 0;\n        minCanvasHeight = num(options.minCanvasHeight) || 0;\n\n        if (viewMode) {\n          if (viewMode > 1) {\n            minCanvasWidth = max(minCanvasWidth, containerWidth);\n            minCanvasHeight = max(minCanvasHeight, containerHeight);\n\n            if (viewMode === 3) {\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          } else {\n            if (minCanvasWidth) {\n              minCanvasWidth = max(minCanvasWidth, isCropped ? cropBox.width : 0);\n            } else if (minCanvasHeight) {\n              minCanvasHeight = max(minCanvasHeight, isCropped ? cropBox.height : 0);\n            } else if (isCropped) {\n              minCanvasWidth = cropBox.width;\n              minCanvasHeight = cropBox.height;\n\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          }\n        }\n\n        if (minCanvasWidth && minCanvasHeight) {\n          if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n            minCanvasHeight = minCanvasWidth / aspectRatio;\n          } else {\n            minCanvasWidth = minCanvasHeight * aspectRatio;\n          }\n        } else if (minCanvasWidth) {\n          minCanvasHeight = minCanvasWidth / aspectRatio;\n        } else if (minCanvasHeight) {\n          minCanvasWidth = minCanvasHeight * aspectRatio;\n        }\n\n        canvas.minWidth = minCanvasWidth;\n        canvas.minHeight = minCanvasHeight;\n        canvas.maxWidth = Infinity;\n        canvas.maxHeight = Infinity;\n      }\n\n      if (isPositionLimited) {\n        if (viewMode) {\n          newCanvasLeft = containerWidth - canvas.width;\n          newCanvasTop = containerHeight - canvas.height;\n\n          canvas.minLeft = min(0, newCanvasLeft);\n          canvas.minTop = min(0, newCanvasTop);\n          canvas.maxLeft = max(0, newCanvasLeft);\n          canvas.maxTop = max(0, newCanvasTop);\n\n          if (isCropped && this.isLimited) {\n            canvas.minLeft = min(\n              cropBox.left,\n              cropBox.left + cropBox.width - canvas.width\n            );\n            canvas.minTop = min(\n              cropBox.top,\n              cropBox.top + cropBox.height - canvas.height\n            );\n            canvas.maxLeft = cropBox.left;\n            canvas.maxTop = cropBox.top;\n\n            if (viewMode === 2) {\n              if (canvas.width >= containerWidth) {\n                canvas.minLeft = min(0, newCanvasLeft);\n                canvas.maxLeft = max(0, newCanvasLeft);\n              }\n\n              if (canvas.height >= containerHeight) {\n                canvas.minTop = min(0, newCanvasTop);\n                canvas.maxTop = max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvas.minLeft = -canvas.width;\n          canvas.minTop = -canvas.height;\n          canvas.maxLeft = containerWidth;\n          canvas.maxTop = containerHeight;\n        }\n      }\n    },\n\n    renderCanvas: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var rotate = image.rotate;\n      var naturalWidth = image.naturalWidth;\n      var naturalHeight = image.naturalHeight;\n      var aspectRatio;\n      var rotated;\n\n      if (this.isRotated) {\n        this.isRotated = false;\n\n        // Computes rotated sizes with image sizes\n        rotated = getRotatedSizes({\n          width: image.width,\n          height: image.height,\n          degree: rotate\n        });\n\n        aspectRatio = rotated.width / rotated.height;\n\n        if (aspectRatio !== canvas.aspectRatio) {\n          canvas.left -= (rotated.width - canvas.width) / 2;\n          canvas.top -= (rotated.height - canvas.height) / 2;\n          canvas.width = rotated.width;\n          canvas.height = rotated.height;\n          canvas.aspectRatio = aspectRatio;\n          canvas.naturalWidth = naturalWidth;\n          canvas.naturalHeight = naturalHeight;\n\n          // Computes rotated sizes with natural image sizes\n          if (rotate % 180) {\n            rotated = getRotatedSizes({\n              width: naturalWidth,\n              height: naturalHeight,\n              degree: rotate\n            });\n\n            canvas.naturalWidth = rotated.width;\n            canvas.naturalHeight = rotated.height;\n          }\n\n          this.limitCanvas(true, false);\n        }\n      }\n\n      if (canvas.width > canvas.maxWidth || canvas.width < canvas.minWidth) {\n        canvas.left = canvas.oldLeft;\n      }\n\n      if (canvas.height > canvas.maxHeight || canvas.height < canvas.minHeight) {\n        canvas.top = canvas.oldTop;\n      }\n\n      canvas.width = min(max(canvas.width, canvas.minWidth), canvas.maxWidth);\n      canvas.height = min(max(canvas.height, canvas.minHeight), canvas.maxHeight);\n\n      this.limitCanvas(false, true);\n\n      canvas.oldLeft = canvas.left = min(max(canvas.left, canvas.minLeft), canvas.maxLeft);\n      canvas.oldTop = canvas.top = min(max(canvas.top, canvas.minTop), canvas.maxTop);\n\n      this.$canvas.css({\n        width: canvas.width,\n        height: canvas.height,\n        left: canvas.left,\n        top: canvas.top\n      });\n\n      this.renderImage();\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCropBox(true, true);\n      }\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    renderImage: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var reversed;\n\n      if (image.rotate) {\n        reversed = getRotatedSizes({\n          width: canvas.width,\n          height: canvas.height,\n          degree: image.rotate,\n          aspectRatio: image.aspectRatio\n        }, true);\n      }\n\n      $.extend(image, reversed ? {\n        width: reversed.width,\n        height: reversed.height,\n        left: (canvas.width - reversed.width) / 2,\n        top: (canvas.height - reversed.height) / 2\n      } : {\n        width: canvas.width,\n        height: canvas.height,\n        left: 0,\n        top: 0\n      });\n\n      this.$clone.css({\n        width: image.width,\n        height: image.height,\n        marginLeft: image.left,\n        marginTop: image.top,\n        transform: getTransform(image)\n      });\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    initCropBox: function () {\n      var options = this.options;\n      var canvas = this.canvas;\n      var aspectRatio = options.aspectRatio;\n      var autoCropArea = num(options.autoCropArea) || 0.8;\n      var cropBox = {\n            width: canvas.width,\n            height: canvas.height\n          };\n\n      if (aspectRatio) {\n        if (canvas.height * aspectRatio > canvas.width) {\n          cropBox.height = cropBox.width / aspectRatio;\n        } else {\n          cropBox.width = cropBox.height * aspectRatio;\n        }\n      }\n\n      this.cropBox = cropBox;\n      this.limitCropBox(true, true);\n\n      // Initialize auto crop area\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      // The width of auto crop area must large than \"minWidth\", and the height too. (#164)\n      cropBox.width = max(cropBox.minWidth, cropBox.width * autoCropArea);\n      cropBox.height = max(cropBox.minHeight, cropBox.height * autoCropArea);\n      cropBox.oldLeft = cropBox.left = canvas.left + (canvas.width - cropBox.width) / 2;\n      cropBox.oldTop = cropBox.top = canvas.top + (canvas.height - cropBox.height) / 2;\n\n      this.initialCropBox = $.extend({}, cropBox);\n    },\n\n    limitCropBox: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var isLimited = this.isLimited;\n      var minCropBoxWidth;\n      var minCropBoxHeight;\n      var maxCropBoxWidth;\n      var maxCropBoxHeight;\n\n      if (isSizeLimited) {\n        minCropBoxWidth = num(options.minCropBoxWidth) || 0;\n        minCropBoxHeight = num(options.minCropBoxHeight) || 0;\n\n        // The min/maxCropBoxWidth/Height must be less than containerWidth/Height\n        minCropBoxWidth = min(minCropBoxWidth, containerWidth);\n        minCropBoxHeight = min(minCropBoxHeight, containerHeight);\n        maxCropBoxWidth = min(containerWidth, isLimited ? canvas.width : containerWidth);\n        maxCropBoxHeight = min(containerHeight, isLimited ? canvas.height : containerHeight);\n\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        }\n\n        // The minWidth/Height must be less than maxWidth/Height\n        cropBox.minWidth = min(minCropBoxWidth, maxCropBoxWidth);\n        cropBox.minHeight = min(minCropBoxHeight, maxCropBoxHeight);\n        cropBox.maxWidth = maxCropBoxWidth;\n        cropBox.maxHeight = maxCropBoxHeight;\n      }\n\n      if (isPositionLimited) {\n        if (isLimited) {\n          cropBox.minLeft = max(0, canvas.left);\n          cropBox.minTop = max(0, canvas.top);\n          cropBox.maxLeft = min(containerWidth, canvas.left + canvas.width) - cropBox.width;\n          cropBox.maxTop = min(containerHeight, canvas.top + canvas.height) - cropBox.height;\n        } else {\n          cropBox.minLeft = 0;\n          cropBox.minTop = 0;\n          cropBox.maxLeft = containerWidth - cropBox.width;\n          cropBox.maxTop = containerHeight - cropBox.height;\n        }\n      }\n    },\n\n    renderCropBox: function () {\n      var options = this.options;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var cropBox = this.cropBox;\n\n      if (cropBox.width > cropBox.maxWidth || cropBox.width < cropBox.minWidth) {\n        cropBox.left = cropBox.oldLeft;\n      }\n\n      if (cropBox.height > cropBox.maxHeight || cropBox.height < cropBox.minHeight) {\n        cropBox.top = cropBox.oldTop;\n      }\n\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      this.limitCropBox(false, true);\n\n      cropBox.oldLeft = cropBox.left = min(max(cropBox.left, cropBox.minLeft), cropBox.maxLeft);\n      cropBox.oldTop = cropBox.top = min(max(cropBox.top, cropBox.minTop), cropBox.maxTop);\n\n      if (options.movable && options.cropBoxMovable) {\n\n        // Turn to move the canvas when the crop box is equal to the container\n        this.$face.data(DATA_ACTION, (cropBox.width === containerWidth && cropBox.height === containerHeight) ? ACTION_MOVE : ACTION_ALL);\n      }\n\n      this.$cropBox.css({\n        width: cropBox.width,\n        height: cropBox.height,\n        left: cropBox.left,\n        top: cropBox.top\n      });\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCanvas(true, true);\n      }\n\n      if (!this.isDisabled) {\n        this.output();\n      }\n    },\n\n    output: function () {\n      this.preview();\n\n      if (this.isCompleted) {\n        this.trigger(EVENT_CROP, this.getData());\n      } else if (!this.isBuilt) {\n\n        // Only trigger one crop event before complete\n        this.$element.one(EVENT_BUILT, $.proxy(function () {\n          this.trigger(EVENT_CROP, this.getData());\n        }, this));\n      }\n    },\n\n    initPreview: function () {\n      var crossOrigin = getCrossOrigin(this.crossOrigin);\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var $clone2;\n\n      this.$preview = $(this.options.preview);\n      this.$clone2 = $clone2 = $('<img' + crossOrigin + ' src=\"' + url + '\">');\n      this.$viewBox.html($clone2);\n      this.$preview.each(function () {\n        var $this = $(this);\n\n        // Save the original size for recover\n        $this.data(DATA_PREVIEW, {\n          width: $this.width(),\n          height: $this.height(),\n          html: $this.html()\n        });\n\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * (Occur only when margin-top <= -height)\n         */\n        $this.html(\n          '<img' + crossOrigin + ' src=\"' + url + '\" style=\"' +\n          'display:block;width:100%;height:auto;' +\n          'min-width:0!important;min-height:0!important;' +\n          'max-width:none!important;max-height:none!important;' +\n          'image-orientation:0deg!important;\">'\n        );\n      });\n    },\n\n    resetPreview: function () {\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n\n        $this.css({\n          width: data.width,\n          height: data.height\n        }).html(data.html).removeData(DATA_PREVIEW);\n      });\n    },\n\n    preview: function () {\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var cropBoxWidth = cropBox.width;\n      var cropBoxHeight = cropBox.height;\n      var width = image.width;\n      var height = image.height;\n      var left = cropBox.left - canvas.left - image.left;\n      var top = cropBox.top - canvas.top - image.top;\n\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      this.$clone2.css({\n        width: width,\n        height: height,\n        marginLeft: -left,\n        marginTop: -top,\n        transform: getTransform(image)\n      });\n\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n\n        $this.css({\n          width: newWidth,\n          height: newHeight\n        }).find('img').css({\n          width: width * ratio,\n          height: height * ratio,\n          marginLeft: -left * ratio,\n          marginTop: -top * ratio,\n          transform: getTransform(image)\n        });\n      });\n    },\n\n    bind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.on(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.on(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.on(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.on(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.on(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.on(EVENT_MOUSE_DOWN, $.proxy(this.cropStart, this));\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.on(EVENT_WHEEL, $.proxy(this.wheel, this));\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.on(EVENT_DBLCLICK, $.proxy(this.dblclick, this));\n      }\n\n      $document.\n        on(EVENT_MOUSE_MOVE, (this._cropMove = proxy(this.cropMove, this))).\n        on(EVENT_MOUSE_UP, (this._cropEnd = proxy(this.cropEnd, this)));\n\n      if (options.responsive) {\n        $window.on(EVENT_RESIZE, (this._resize = proxy(this.resize, this)));\n      }\n    },\n\n    unbind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.off(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.off(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.off(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.off(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.off(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.off(EVENT_MOUSE_DOWN, this.cropStart);\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.off(EVENT_WHEEL, this.wheel);\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.off(EVENT_DBLCLICK, this.dblclick);\n      }\n\n      $document.\n        off(EVENT_MOUSE_MOVE, this._cropMove).\n        off(EVENT_MOUSE_UP, this._cropEnd);\n\n      if (options.responsive) {\n        $window.off(EVENT_RESIZE, this._resize);\n      }\n    },\n\n    resize: function () {\n      var restore = this.options.restore;\n      var $container = this.$container;\n      var container = this.container;\n      var canvasData;\n      var cropBoxData;\n      var ratio;\n\n      // Check `container` is necessary for IE8\n      if (this.isDisabled || !container) {\n        return;\n      }\n\n      ratio = $container.width() / container.width;\n\n      // Resize when width changed or height changed\n      if (ratio !== 1 || $container.height() !== container.height) {\n        if (restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n\n        this.render();\n\n        if (restore) {\n          this.setCanvasData($.each(canvasData, function (i, n) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData($.each(cropBoxData, function (i, n) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n\n    dblclick: function () {\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (this.$dragBox.hasClass(CLASS_CROP)) {\n        this.setDragMode(ACTION_MOVE);\n      } else {\n        this.setDragMode(ACTION_CROP);\n      }\n    },\n\n    wheel: function (event) {\n      var e = event.originalEvent || event;\n      var ratio = num(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      event.preventDefault();\n\n      // Limit wheel speed to prevent zoom too fast\n      if (this.wheeling) {\n        return;\n      }\n\n      this.wheeling = true;\n\n      setTimeout($.proxy(function () {\n        this.wheeling = false;\n      }, this), 50);\n\n      if (e.deltaY) {\n        delta = e.deltaY > 0 ? 1 : -1;\n      } else if (e.wheelDelta) {\n        delta = -e.wheelDelta / 120;\n      } else if (e.detail) {\n        delta = e.detail > 0 ? 1 : -1;\n      }\n\n      this.zoom(-delta * ratio, event);\n    },\n\n    cropStart: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var touchesLength;\n      var action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.startX2 = e.pageX;\n            this.startY2 = e.pageY;\n            action = ACTION_ZOOM;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      action = action || $(e.target).data(DATA_ACTION);\n\n      if (REGEXP_ACTIONS.test(action)) {\n        if (this.trigger(EVENT_CROP_START, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.action = action;\n        this.cropping = false;\n\n        // IE8  has `event.pageX/Y`, but not `event.originalEvent.pageX/Y`\n        // IE10 has `event.originalEvent.pageX/Y`, but not `event.pageX/Y`\n        this.startX = e.pageX || originalEvent && originalEvent.pageX;\n        this.startY = e.pageY || originalEvent && originalEvent.pageY;\n\n        if (action === ACTION_CROP) {\n          this.cropping = true;\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      }\n    },\n\n    cropMove: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var action = this.action;\n      var touchesLength;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.endX2 = e.pageX;\n            this.endY2 = e.pageY;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      if (action) {\n        if (this.trigger(EVENT_CROP_MOVE, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.endX = e.pageX || originalEvent && originalEvent.pageX;\n        this.endY = e.pageY || originalEvent && originalEvent.pageY;\n\n        this.change(e.shiftKey, action === ACTION_ZOOM ? event : null);\n      }\n    },\n\n    cropEnd: function (event) {\n      var originalEvent = event.originalEvent;\n      var action = this.action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (action) {\n        event.preventDefault();\n\n        if (this.cropping) {\n          this.cropping = false;\n          this.$dragBox.toggleClass(CLASS_MODAL, this.isCropped && this.options.modal);\n        }\n\n        this.action = '';\n\n        this.trigger(EVENT_CROP_END, {\n          originalEvent: originalEvent,\n          action: action\n        });\n      }\n    },\n\n    change: function (shiftKey, event) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var action = this.action;\n      var container = this.container;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var width = cropBox.width;\n      var height = cropBox.height;\n      var left = cropBox.left;\n      var top = cropBox.top;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = container.width;\n      var maxHeight = container.height;\n      var renderable = true;\n      var offset;\n      var range;\n\n      // Locking aspect ratio in \"free mode\" by holding shift key (#259)\n      if (!aspectRatio && shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n\n      if (this.limited) {\n        minLeft = cropBox.minLeft;\n        minTop = cropBox.minTop;\n        maxWidth = minLeft + min(container.width, canvas.left + canvas.width);\n        maxHeight = minTop + min(container.height, canvas.top + canvas.height);\n      }\n\n      range = {\n        x: this.endX - this.startX,\n        y: this.endY - this.startY\n      };\n\n      if (aspectRatio) {\n        range.X = range.y * aspectRatio;\n        range.Y = range.x / aspectRatio;\n      }\n\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n\n        // Resize crop box\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top -= range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height -= range.y;\n          top += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width -= range.x;\n          left += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left -= range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += range.X;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        // Move canvas\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n\n        // Zoom canvas\n        case ACTION_ZOOM:\n          this.zoom((function (x1, y1, x2, y2) {\n            var z1 = sqrt(x1 * x1 + y1 * y1);\n            var z2 = sqrt(x2 * x2 + y2 * y2);\n\n            return (z2 - z1) / z1;\n          })(\n            abs(this.startX - this.startX2),\n            abs(this.startY - this.startY2),\n            abs(this.endX - this.endX2),\n            abs(this.endY - this.endY2)\n          ), event);\n          this.startX2 = this.endX2;\n          this.startY2 = this.endY2;\n          renderable = false;\n          break;\n\n        // Create crop box\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n\n          offset = this.$cropper.offset();\n          left = this.startX - offset.left;\n          top = this.startY - offset.top;\n          width = cropBox.minWidth;\n          height = cropBox.minHeight;\n\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n\n          if (range.y < 0) {\n            top -= height;\n          }\n\n          // Show the crop box if is hidden\n          if (!this.isCropped) {\n            this.$cropBox.removeClass(CLASS_HIDDEN);\n            this.isCropped = true;\n\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n\n          break;\n\n        // No default\n      }\n\n      if (renderable) {\n        cropBox.width = width;\n        cropBox.height = height;\n        cropBox.left = left;\n        cropBox.top = top;\n        this.action = action;\n\n        this.renderCropBox();\n      }\n\n      // Override\n      this.startX = this.endX;\n      this.startY = this.endY;\n    },\n\n    // Show the crop box manually\n    crop: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      if (!this.isCropped) {\n        this.isCropped = true;\n        this.limitCropBox(true, true);\n\n        if (this.options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n\n        this.$cropBox.removeClass(CLASS_HIDDEN);\n      }\n\n      this.setCropBoxData(this.initialCropBox);\n    },\n\n    // Reset the image and crop box to their initial states\n    reset: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      this.image = $.extend({}, this.initialImage);\n      this.canvas = $.extend({}, this.initialCanvas);\n      this.cropBox = $.extend({}, this.initialCropBox);\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    // Clear the crop box\n    clear: function () {\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      $.extend(this.cropBox, {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      });\n\n      this.isCropped = false;\n      this.renderCropBox();\n\n      this.limitCanvas(true, true);\n\n      // Render canvas after crop box rendered\n      this.renderCanvas();\n\n      this.$dragBox.removeClass(CLASS_MODAL);\n      this.$cropBox.addClass(CLASS_HIDDEN);\n    },\n\n    /**\n     * Replace the image's src and rebuild the cropper\n     *\n     * @param {String} url\n     * @param {Boolean} onlyColorChanged (optional)\n     */\n    replace: function (url, onlyColorChanged) {\n      if (!this.isDisabled && url) {\n        if (this.isImg) {\n          this.$element.attr('src', url);\n        }\n\n        if (onlyColorChanged) {\n          this.url = url;\n          this.$clone.attr('src', url);\n\n          if (this.isBuilt) {\n            this.$preview.find('img').add(this.$clone2).attr('src', url);\n          }\n        } else {\n          if (this.isImg) {\n            this.isReplaced = true;\n          }\n\n          // Clear previous data\n          this.options.data = null;\n          this.load(url);\n        }\n      }\n    },\n\n    // Enable (unfreeze) the cropper\n    enable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = false;\n        this.$cropper.removeClass(CLASS_DISABLED);\n      }\n    },\n\n    // Disable (freeze) the cropper\n    disable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = true;\n        this.$cropper.addClass(CLASS_DISABLED);\n      }\n    },\n\n    // Destroy the cropper and remove the instance from the image\n    destroy: function () {\n      var $this = this.$element;\n\n      if (this.isLoaded) {\n        if (this.isImg && this.isReplaced) {\n          $this.attr('src', this.originalUrl);\n        }\n\n        this.unbuild();\n        $this.removeClass(CLASS_HIDDEN);\n      } else {\n        if (this.isImg) {\n          $this.off(EVENT_LOAD, this.start);\n        } else if (this.$clone) {\n          this.$clone.remove();\n        }\n      }\n\n      $this.removeData(NAMESPACE);\n    },\n\n    /**\n     * Move the canvas with relative offsets\n     *\n     * @param {Number} offsetX\n     * @param {Number} offsetY (optional)\n     */\n    move: function (offsetX, offsetY) {\n      var canvas = this.canvas;\n\n      this.moveTo(\n        isUndefined(offsetX) ? offsetX : canvas.left + num(offsetX),\n        isUndefined(offsetY) ? offsetY : canvas.top + num(offsetY)\n      );\n    },\n\n    /**\n     * Move the canvas to an absolute point\n     *\n     * @param {Number} x\n     * @param {Number} y (optional)\n     */\n    moveTo: function (x, y) {\n      var canvas = this.canvas;\n      var isChanged = false;\n\n      // If \"y\" is not present, its default value is \"x\"\n      if (isUndefined(y)) {\n        y = x;\n      }\n\n      x = num(x);\n      y = num(y);\n\n      if (this.isBuilt && !this.isDisabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvas.left = x;\n          isChanged = true;\n        }\n\n        if (isNumber(y)) {\n          canvas.top = y;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderCanvas(true);\n        }\n      }\n    },\n\n    /**\n     * Zoom the canvas with a relative ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoom: function (ratio, _event) {\n      var canvas = this.canvas;\n\n      ratio = num(ratio);\n\n      if (ratio < 0) {\n        ratio =  1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n\n      this.zoomTo(canvas.width * ratio / canvas.naturalWidth, _event);\n    },\n\n    /**\n     * Zoom the canvas to an absolute ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoomTo: function (ratio, _event) {\n      var options = this.options;\n      var canvas = this.canvas;\n      var width = canvas.width;\n      var height = canvas.height;\n      var naturalWidth = canvas.naturalWidth;\n      var naturalHeight = canvas.naturalHeight;\n      var originalEvent;\n      var newWidth;\n      var newHeight;\n      var offset;\n      var center;\n\n      ratio = num(ratio);\n\n      if (ratio >= 0 && this.isBuilt && !this.isDisabled && options.zoomable) {\n        newWidth = naturalWidth * ratio;\n        newHeight = naturalHeight * ratio;\n\n        if (_event) {\n          originalEvent = _event.originalEvent;\n        }\n\n        if (this.trigger(EVENT_ZOOM, {\n          originalEvent: originalEvent,\n          oldRatio: width / naturalWidth,\n          ratio: newWidth / naturalWidth\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        if (originalEvent) {\n          offset = this.$cropper.offset();\n          center = originalEvent.touches ? getTouchesCenter(originalEvent.touches) : {\n            pageX: _event.pageX || originalEvent.pageX || 0,\n            pageY: _event.pageY || originalEvent.pageY || 0\n          };\n\n          // Zoom from the triggering point of the event\n          canvas.left -= (newWidth - width) * (\n            ((center.pageX - offset.left) - canvas.left) / width\n          );\n          canvas.top -= (newHeight - height) * (\n            ((center.pageY - offset.top) - canvas.top) / height\n          );\n        } else {\n\n          // Zoom from the center of the canvas\n          canvas.left -= (newWidth - width) / 2;\n          canvas.top -= (newHeight - height) / 2;\n        }\n\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Rotate the canvas with a relative degree\n     *\n     * @param {Number} degree\n     */\n    rotate: function (degree) {\n      this.rotateTo((this.image.rotate || 0) + num(degree));\n    },\n\n    /**\n     * Rotate the canvas to an absolute degree\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()\n     *\n     * @param {Number} degree\n     */\n    rotateTo: function (degree) {\n      degree = num(degree);\n\n      if (isNumber(degree) && this.isBuilt && !this.isDisabled && this.options.rotatable) {\n        this.image.rotate = degree % 360;\n        this.isRotated = true;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Scale the image\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()\n     *\n     * @param {Number} scaleX\n     * @param {Number} scaleY (optional)\n     */\n    scale: function (scaleX, scaleY) {\n      var image = this.image;\n      var isChanged = false;\n\n      // If \"scaleY\" is not present, its default value is \"scaleX\"\n      if (isUndefined(scaleY)) {\n        scaleY = scaleX;\n      }\n\n      scaleX = num(scaleX);\n      scaleY = num(scaleY);\n\n      if (this.isBuilt && !this.isDisabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          image.scaleX = scaleX;\n          isChanged = true;\n        }\n\n        if (isNumber(scaleY)) {\n          image.scaleY = scaleY;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderImage(true);\n        }\n      }\n    },\n\n    /**\n     * Scale the abscissa of the image\n     *\n     * @param {Number} scaleX\n     */\n    scaleX: function (scaleX) {\n      var scaleY = this.image.scaleY;\n\n      this.scale(scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n\n    /**\n     * Scale the ordinate of the image\n     *\n     * @param {Number} scaleY\n     */\n    scaleY: function (scaleY) {\n      var scaleX = this.image.scaleX;\n\n      this.scale(isNumber(scaleX) ? scaleX : 1, scaleY);\n    },\n\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     *\n     * @param {Boolean} isRounded (optional)\n     * @return {Object} data\n     */\n    getData: function (isRounded) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var ratio;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          x: cropBox.left - canvas.left,\n          y: cropBox.top - canvas.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n\n        ratio = image.width / image.naturalWidth;\n\n        $.each(data, function (i, n) {\n          n = n / ratio;\n          data[i] = isRounded ? round(n) : n;\n        });\n\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (options.rotatable) {\n        data.rotate = image.rotate || 0;\n      }\n\n      if (options.scalable) {\n        data.scaleX = image.scaleX || 1;\n        data.scaleY = image.scaleY || 1;\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the cropped area position and size with new data\n     *\n     * @param {Object} data\n     */\n    setData: function (data) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBoxData = {};\n      var isRotated;\n      var isScaled;\n      var ratio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== image.rotate) {\n            image.rotate = data.rotate;\n            this.isRotated = isRotated = true;\n          }\n        }\n\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== image.scaleX) {\n            image.scaleX = data.scaleX;\n            isScaled = true;\n          }\n\n          if (isNumber(data.scaleY) && data.scaleY !== image.scaleY) {\n            image.scaleY = data.scaleY;\n            isScaled = true;\n          }\n        }\n\n        if (isRotated) {\n          this.renderCanvas();\n        } else if (isScaled) {\n          this.renderImage();\n        }\n\n        ratio = image.width / image.naturalWidth;\n\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvas.left;\n        }\n\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvas.top;\n        }\n\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n\n        this.setCropBoxData(cropBoxData);\n      }\n    },\n\n    /**\n     * Get the container size data\n     *\n     * @return {Object} data\n     */\n    getContainerData: function () {\n      return this.isBuilt ? this.container : {};\n    },\n\n    /**\n     * Get the image position and size data\n     *\n     * @return {Object} data\n     */\n    getImageData: function () {\n      return this.isLoaded ? this.image : {};\n    },\n\n    /**\n     * Get the canvas position and size data\n     *\n     * @return {Object} data\n     */\n    getCanvasData: function () {\n      var canvas = this.canvas;\n      var data = {};\n\n      if (this.isBuilt) {\n        $.each([\n          'left',\n          'top',\n          'width',\n          'height',\n          'naturalWidth',\n          'naturalHeight'\n        ], function (i, n) {\n          data[n] = canvas[n];\n        });\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the canvas position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCanvasData: function (data) {\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvas.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          canvas.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          canvas.width = data.width;\n          canvas.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvas.height = data.height;\n          canvas.width = data.height * aspectRatio;\n        }\n\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Get the crop box position and size data\n     *\n     * @return {Object} data\n     */\n    getCropBoxData: function () {\n      var cropBox = this.cropBox;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          left: cropBox.left,\n          top: cropBox.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n      }\n\n      return data || {};\n    },\n\n    /**\n     * Set the crop box position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCropBoxData: function (data) {\n      var cropBox = this.cropBox;\n      var aspectRatio = this.options.aspectRatio;\n      var isWidthChanged;\n      var isHeightChanged;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && this.isCropped && !this.isDisabled && $.isPlainObject(data)) {\n\n        if (isNumber(data.left)) {\n          cropBox.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          cropBox.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          isWidthChanged = true;\n          cropBox.width = data.width;\n        }\n\n        if (isNumber(data.height)) {\n          isHeightChanged = true;\n          cropBox.height = data.height;\n        }\n\n        if (aspectRatio) {\n          if (isWidthChanged) {\n            cropBox.height = cropBox.width / aspectRatio;\n          } else if (isHeightChanged) {\n            cropBox.width = cropBox.height * aspectRatio;\n          }\n        }\n\n        this.renderCropBox();\n      }\n    },\n\n    /**\n     * Get a canvas drawn the cropped image\n     *\n     * @param {Object} options (optional)\n     * @return {HTMLCanvasElement} canvas\n     */\n    getCroppedCanvas: function (options) {\n      var originalWidth;\n      var originalHeight;\n      var canvasWidth;\n      var canvasHeight;\n      var scaledWidth;\n      var scaledHeight;\n      var scaledRatio;\n      var aspectRatio;\n      var canvas;\n      var context;\n      var data;\n\n      if (!this.isBuilt || !this.isCropped || !SUPPORT_CANVAS) {\n        return;\n      }\n\n      if (!$.isPlainObject(options)) {\n        options = {};\n      }\n\n      data = this.getData();\n      originalWidth = data.width;\n      originalHeight = data.height;\n      aspectRatio = originalWidth / originalHeight;\n\n      if ($.isPlainObject(options)) {\n        scaledWidth = options.width;\n        scaledHeight = options.height;\n\n        if (scaledWidth) {\n          scaledHeight = scaledWidth / aspectRatio;\n          scaledRatio = scaledWidth / originalWidth;\n        } else if (scaledHeight) {\n          scaledWidth = scaledHeight * aspectRatio;\n          scaledRatio = scaledHeight / originalHeight;\n        }\n      }\n\n      // The canvas element will use `Math.floor` on a float number, so floor first\n      canvasWidth = floor(scaledWidth || originalWidth);\n      canvasHeight = floor(scaledHeight || originalHeight);\n\n      canvas = $('<canvas>')[0];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      context = canvas.getContext('2d');\n\n      if (options.fillColor) {\n        context.fillStyle = options.fillColor;\n        context.fillRect(0, 0, canvasWidth, canvasHeight);\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n      context.drawImage.apply(context, (function () {\n        var source = getSourceCanvas(this.$clone[0], this.image);\n        var sourceWidth = source.width;\n        var sourceHeight = source.height;\n        var canvas = this.canvas;\n        var params = [source];\n\n        // Source canvas\n        var srcX = data.x + canvas.naturalWidth * (abs(data.scaleX || 1) - 1) / 2;\n        var srcY = data.y + canvas.naturalHeight * (abs(data.scaleY || 1) - 1) / 2;\n        var srcWidth;\n        var srcHeight;\n\n        // Destination canvas\n        var dstX;\n        var dstY;\n        var dstWidth;\n        var dstHeight;\n\n        if (srcX <= -originalWidth || srcX > sourceWidth) {\n          srcX = srcWidth = dstX = dstWidth = 0;\n        } else if (srcX <= 0) {\n          dstX = -srcX;\n          srcX = 0;\n          srcWidth = dstWidth = min(sourceWidth, originalWidth + srcX);\n        } else if (srcX <= sourceWidth) {\n          dstX = 0;\n          srcWidth = dstWidth = min(originalWidth, sourceWidth - srcX);\n        }\n\n        if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {\n          srcY = srcHeight = dstY = dstHeight = 0;\n        } else if (srcY <= 0) {\n          dstY = -srcY;\n          srcY = 0;\n          srcHeight = dstHeight = min(sourceHeight, originalHeight + srcY);\n        } else if (srcY <= sourceHeight) {\n          dstY = 0;\n          srcHeight = dstHeight = min(originalHeight, sourceHeight - srcY);\n        }\n\n        // All the numerical parameters should be integer for `drawImage` (#476)\n        params.push(floor(srcX), floor(srcY), floor(srcWidth), floor(srcHeight));\n\n        // Scale destination sizes\n        if (scaledRatio) {\n          dstX *= scaledRatio;\n          dstY *= scaledRatio;\n          dstWidth *= scaledRatio;\n          dstHeight *= scaledRatio;\n        }\n\n        // Avoid \"IndexSizeError\" in IE and Firefox\n        if (dstWidth > 0 && dstHeight > 0) {\n          params.push(floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n        }\n\n        return params;\n      }).call(this));\n\n      return canvas;\n    },\n\n    /**\n     * Change the aspect ratio of the crop box\n     *\n     * @param {Number} aspectRatio\n     */\n    setAspectRatio: function (aspectRatio) {\n      var options = this.options;\n\n      if (!this.isDisabled && !isUndefined(aspectRatio)) {\n\n        // 0 -> NaN\n        options.aspectRatio = max(0, aspectRatio) || NaN;\n\n        if (this.isBuilt) {\n          this.initCropBox();\n\n          if (this.isCropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n    },\n\n    /**\n     * Change the drag mode\n     *\n     * @param {String} mode (optional)\n     */\n    setDragMode: function (mode) {\n      var options = this.options;\n      var croppable;\n      var movable;\n\n      if (this.isLoaded && !this.isDisabled) {\n        croppable = mode === ACTION_CROP;\n        movable = options.movable && mode === ACTION_MOVE;\n        mode = (croppable || movable) ? mode : ACTION_NONE;\n\n        this.$dragBox.\n          data(DATA_ACTION, mode).\n          toggleClass(CLASS_CROP, croppable).\n          toggleClass(CLASS_MOVE, movable);\n\n        if (!options.cropBoxMovable) {\n\n          // Sync drag mode to crop box when it is not movable(#300)\n          this.$face.\n            data(DATA_ACTION, mode).\n            toggleClass(CLASS_CROP, croppable).\n            toggleClass(CLASS_MOVE, movable);\n        }\n      }\n    }\n  };\n\n  Cropper.DEFAULTS = {\n\n    // Define the view mode of the cropper\n    viewMode: 0, // 0, 1, 2, 3\n\n    // Define the dragging mode of the cropper\n    dragMode: 'crop', // 'crop', 'move' or 'none'\n\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n\n    // An object with the previous cropping result data\n    data: null,\n\n    // A jQuery selector for adding extra containers to preview\n    preview: '',\n\n    // Re-render the cropper when resize the window\n    responsive: true,\n\n    // Restore the cropped area after resize the window\n    restore: true,\n\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n\n    // Show the black modal\n    modal: true,\n\n    // Show the dashed lines for guiding\n    guides: true,\n\n    // Show the center indicator for guiding\n    center: true,\n\n    // Show the white modal to highlight the crop box\n    highlight: true,\n\n    // Show the grid background\n    background: true,\n\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n\n    // Enable to move the image\n    movable: true,\n\n    // Enable to rotate the image\n    rotatable: true,\n\n    // Enable to scale the image\n    scalable: true,\n\n    // Enable to zoom the image\n    zoomable: true,\n\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n\n    // Enable to move the crop box\n    cropBoxMovable: true,\n\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: 200,\n    minContainerHeight: 100,\n\n    // Shortcuts of events\n    build: null,\n    built: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n\n  Cropper.setDefaults = function (options) {\n    $.extend(Cropper.DEFAULTS, options);\n  };\n\n  Cropper.TEMPLATE = (\n    '<div class=\"cropper-container\">' +\n      '<div class=\"cropper-wrap-box\">' +\n        '<div class=\"cropper-canvas\"></div>' +\n      '</div>' +\n      '<div class=\"cropper-drag-box\"></div>' +\n      '<div class=\"cropper-crop-box\">' +\n        '<span class=\"cropper-view-box\"></span>' +\n        '<span class=\"cropper-dashed dashed-h\"></span>' +\n        '<span class=\"cropper-dashed dashed-v\"></span>' +\n        '<span class=\"cropper-center\"></span>' +\n        '<span class=\"cropper-face\"></span>' +\n        '<span class=\"cropper-line line-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-line line-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-line line-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-line line-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-point point-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-point point-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-point point-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-ne\" data-action=\"ne\"></span>' +\n        '<span class=\"cropper-point point-nw\" data-action=\"nw\"></span>' +\n        '<span class=\"cropper-point point-sw\" data-action=\"sw\"></span>' +\n        '<span class=\"cropper-point point-se\" data-action=\"se\"></span>' +\n      '</div>' +\n    '</div>'\n  );\n\n  // Save the other cropper\n  Cropper.other = $.fn.cropper;\n\n  // Register as jQuery plugin\n  $.fn.cropper = function (option) {\n    var args = toArray(arguments, 1);\n    var result;\n\n    this.each(function () {\n      var $this = $(this);\n      var data = $this.data(NAMESPACE);\n      var options;\n      var fn;\n\n      if (!data) {\n        if (/destroy/.test(option)) {\n          return;\n        }\n\n        options = $.extend({}, $this.data(), $.isPlainObject(option) && option);\n        $this.data(NAMESPACE, (data = new Cropper(this, options)));\n      }\n\n      if (typeof option === 'string' && $.isFunction(fn = data[option])) {\n        result = fn.apply(data, args);\n      }\n    });\n\n    return isUndefined(result) ? this : result;\n  };\n\n  $.fn.cropper.Constructor = Cropper;\n  $.fn.cropper.setDefaults = Cropper.setDefaults;\n\n  // No conflict\n  $.fn.cropper.noConflict = function () {\n    $.fn.cropper = Cropper.other;\n    return this;\n  };\n\n});\n\n\n/***/ }),\n\n/***/ \"dYvO\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($) {var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable comma-dangle, no-unused-vars, class-methods-use-this, quotes, consistent-return, func-names, prefer-arrow-callback, space-before-function-paren, max-len */\n/* global Flash */\n\n(function (global) {\n  var Profile = function () {\n    function Profile() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          form = _ref.form;\n\n      _classCallCheck(this, Profile);\n\n      this.onSubmitForm = this.onSubmitForm.bind(this);\n      this.form = form || $('.edit-user');\n      this.bindEvents();\n      this.initAvatarGlCrop();\n    }\n\n    _createClass(Profile, [{\n      key: 'initAvatarGlCrop',\n      value: function initAvatarGlCrop() {\n        var cropOpts = {\n          filename: '.js-avatar-filename',\n          previewImage: '.avatar-image .avatar',\n          modalCrop: '.modal-profile-crop',\n          pickImageEl: '.js-choose-user-avatar-button',\n          uploadImageBtn: '.js-upload-user-avatar',\n          modalCropImg: '.modal-profile-crop-image'\n        };\n        this.avatarGlCrop = $('.js-user-avatar-input').glCrop(cropOpts).data('glcrop');\n      }\n    }, {\n      key: 'bindEvents',\n      value: function bindEvents() {\n        $('.js-preferences-form').on('change.preference', 'input[type=radio]', this.submitForm);\n        $('#user_notification_email').on('change', this.submitForm);\n        $('#user_notified_of_own_activity').on('change', this.submitForm);\n        $('.update-username').on('ajax:before', this.beforeUpdateUsername);\n        $('.update-username').on('ajax:complete', this.afterUpdateUsername);\n        $('.update-notifications').on('ajax:success', this.onUpdateNotifs);\n        this.form.on('submit', this.onSubmitForm);\n      }\n    }, {\n      key: 'submitForm',\n      value: function submitForm() {\n        return $(this).parents('form').submit();\n      }\n    }, {\n      key: 'onSubmitForm',\n      value: function onSubmitForm(e) {\n        e.preventDefault();\n        return this.saveForm();\n      }\n    }, {\n      key: 'beforeUpdateUsername',\n      value: function beforeUpdateUsername() {\n        $('.loading-username', this).removeClass('hidden');\n      }\n    }, {\n      key: 'afterUpdateUsername',\n      value: function afterUpdateUsername() {\n        $('.loading-username', this).addClass('hidden');\n        $('button[type=submit]', this).enable();\n      }\n    }, {\n      key: 'onUpdateNotifs',\n      value: function onUpdateNotifs(e, data) {\n        return data.saved ? new Flash(\"Notification settings saved\", \"notice\") : new Flash(\"Failed to save new settings\", \"alert\");\n      }\n    }, {\n      key: 'saveForm',\n      value: function saveForm() {\n        var self = this;\n        var formData = new FormData(this.form[0]);\n        var avatarBlob = this.avatarGlCrop.getBlob();\n\n        if (avatarBlob != null) {\n          formData.append('user[avatar]', avatarBlob, 'avatar.png');\n        }\n\n        return $.ajax({\n          url: this.form.attr('action'),\n          type: this.form.attr('method'),\n          data: formData,\n          dataType: \"json\",\n          processData: false,\n          contentType: false,\n          success: function success(response) {\n            return new Flash(response.message, 'notice');\n          },\n          error: function error(jqXHR) {\n            return new Flash(jqXHR.responseJSON.message, 'alert');\n          },\n          complete: function complete() {\n            window.scrollTo(0, 0);\n            // Enable submit button after requests ends\n            return self.form.find(':input[disabled]').enable();\n          }\n        });\n      }\n    }]);\n\n    return Profile;\n  }();\n\n  $(function () {\n    $(document).on('input.ssh_key', '#key_key', function () {\n      var $title = $('#key_title');\n      var comment = $(this).val().match(/^\\S+ \\S+ (.+)\\n?$/);\n\n      // Extract the SSH Key title from its comment\n      if (comment && comment.length > 1) {\n        return $title.val(comment[1]).change();\n      }\n    });\n    if (global.utils.getPagePath() === 'profiles') {\n      return new Profile();\n    }\n  });\n})(window.gl || (window.gl = {}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"lwLq\")))\n\n/***/ })\n\n},[\"RUZQ\"]);\n\n\n// WEBPACK FOOTER //\n// profile.56fab56f950907c5b67a.bundle.js","require('./gl_crop');\nrequire('./profile');\n\n\n\n// WEBPACK FOOTER //\n// ./profile/profile_bundle.js","/* eslint-disable no-useless-escape, max-len, quotes, no-var, no-underscore-dangle, func-names, space-before-function-paren, no-unused-vars, no-return-assign, object-shorthand, one-var, one-var-declaration-per-line, comma-dangle, consistent-return, class-methods-use-this, new-parens */\n\nimport 'vendor/cropper';\n\n((global) => {\n  // Matches everything but the file name\n  const FILENAMEREGEX = /^.*[\\\\\\/]/;\n\n  class GitLabCrop {\n    constructor(input, { filename, previewImage, modalCrop, pickImageEl, uploadImageBtn, modalCropImg,\n        exportWidth = 200, exportHeight = 200, cropBoxWidth = 200, cropBoxHeight = 200 } = {}) {\n      this.onUploadImageBtnClick = this.onUploadImageBtnClick.bind(this);\n      this.onModalHide = this.onModalHide.bind(this);\n      this.onModalShow = this.onModalShow.bind(this);\n      this.onPickImageClick = this.onPickImageClick.bind(this);\n      this.fileInput = $(input);\n      this.modalCropImg = _.isString(this.modalCropImg) ? $(this.modalCropImg) : this.modalCropImg;\n      this.fileInput.attr('name', `${this.fileInput.attr('name')}-trigger`).attr('id', `${this.fileInput.attr('id')}-trigger`);\n      this.exportWidth = exportWidth;\n      this.exportHeight = exportHeight;\n      this.cropBoxWidth = cropBoxWidth;\n      this.cropBoxHeight = cropBoxHeight;\n      this.form = this.fileInput.parents('form');\n      this.filename = filename;\n      this.previewImage = previewImage;\n      this.modalCrop = modalCrop;\n      this.pickImageEl = pickImageEl;\n      this.uploadImageBtn = uploadImageBtn;\n      this.modalCropImg = modalCropImg;\n      this.filename = this.getElement(filename);\n      this.previewImage = this.getElement(previewImage);\n      this.pickImageEl = this.getElement(pickImageEl);\n      this.modalCrop = _.isString(modalCrop) ? $(modalCrop) : modalCrop;\n      this.uploadImageBtn = _.isString(uploadImageBtn) ? $(uploadImageBtn) : uploadImageBtn;\n      this.modalCropImg = _.isString(modalCropImg) ? $(modalCropImg) : modalCropImg;\n      this.cropActionsBtn = this.modalCrop.find('[data-method]');\n      this.bindEvents();\n    }\n\n    getElement(selector) {\n      return $(selector, this.form);\n    }\n\n    bindEvents() {\n      var _this;\n      _this = this;\n      this.fileInput.on('change', function(e) {\n        return _this.onFileInputChange(e, this);\n      });\n      this.pickImageEl.on('click', this.onPickImageClick);\n      this.modalCrop.on('shown.bs.modal', this.onModalShow);\n      this.modalCrop.on('hidden.bs.modal', this.onModalHide);\n      this.uploadImageBtn.on('click', this.onUploadImageBtnClick);\n      this.cropActionsBtn.on('click', function(e) {\n        var btn;\n        btn = this;\n        return _this.onActionBtnClick(btn);\n      });\n      return this.croppedImageBlob = null;\n    }\n\n    onPickImageClick() {\n      return this.fileInput.trigger('click');\n    }\n\n    onModalShow() {\n      var _this;\n      _this = this;\n      return this.modalCropImg.cropper({\n        viewMode: 1,\n        center: false,\n        aspectRatio: 1,\n        modal: true,\n        scalable: false,\n        rotatable: false,\n        zoomable: true,\n        dragMode: 'move',\n        guides: false,\n        zoomOnTouch: false,\n        zoomOnWheel: false,\n        cropBoxMovable: false,\n        cropBoxResizable: false,\n        toggleDragModeOnDblclick: false,\n        built: function() {\n          var $image, container, cropBoxHeight, cropBoxWidth;\n          $image = $(this);\n          container = $image.cropper('getContainerData');\n          cropBoxWidth = _this.cropBoxWidth;\n          cropBoxHeight = _this.cropBoxHeight;\n          return $image.cropper('setCropBoxData', {\n            width: cropBoxWidth,\n            height: cropBoxHeight,\n            left: (container.width - cropBoxWidth) / 2,\n            top: (container.height - cropBoxHeight) / 2\n          });\n        }\n      });\n    }\n\n    onModalHide() {\n      return this.modalCropImg.attr('src', '').cropper('destroy');\n    }\n\n    onUploadImageBtnClick(e) {\n      e.preventDefault();\n      this.setBlob();\n      this.setPreview();\n      this.modalCrop.modal('hide');\n      return this.fileInput.val('');\n    }\n\n    onActionBtnClick(btn) {\n      var data, result;\n      data = $(btn).data();\n      if (this.modalCropImg.data('cropper') && data.method) {\n        return result = this.modalCropImg.cropper(data.method, data.option);\n      }\n    }\n\n    onFileInputChange(e, input) {\n      return this.readFile(input);\n    }\n\n    readFile(input) {\n      var _this, reader;\n      _this = this;\n      reader = new FileReader;\n      reader.onload = () => {\n        _this.modalCropImg.attr('src', reader.result);\n        return _this.modalCrop.modal('show');\n      };\n      return reader.readAsDataURL(input.files[0]);\n    }\n\n    dataURLtoBlob(dataURL) {\n      var array, binary, i, k, len, v;\n      binary = atob(dataURL.split(',')[1]);\n      array = [];\n      for (k = i = 0, len = binary.length; i < len; k = (i += 1)) {\n        v = binary[k];\n        array.push(binary.charCodeAt(k));\n      }\n      return new Blob([new Uint8Array(array)], {\n        type: 'image/png'\n      });\n    }\n\n    setPreview() {\n      var filename;\n      this.previewImage.attr('src', this.dataURL);\n      filename = this.fileInput.val().replace(FILENAMEREGEX, '');\n      return this.filename.text(filename);\n    }\n\n    setBlob() {\n      this.dataURL = this.modalCropImg.cropper('getCroppedCanvas', {\n        width: 200,\n        height: 200\n      }).toDataURL('image/png');\n      return this.croppedImageBlob = this.dataURLtoBlob(this.dataURL);\n    }\n\n    getBlob() {\n      return this.croppedImageBlob;\n    }\n  }\n\n  $.fn.glCrop = function(opts) {\n    return this.each(function() {\n      return $(this).data('glcrop', new GitLabCrop(this, opts));\n    });\n  };\n})(window.gl || (window.gl = {}));\n\n\n\n// WEBPACK FOOTER //\n// ./profile/gl_crop.js","/*!\n * Cropper v2.3.0\n * https://github.com/fengyuanchen/cropper\n *\n * Copyright (c) 2014-2016 Fengyuan Chen and contributors\n * Released under the MIT license\n *\n * Date: 2016-02-22T02:13:13.332Z\n */\n\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof exports === 'object') {\n    // Node / CommonJS\n    factory(require('jquery'));\n  } else {\n    // Browser globals.\n    factory(jQuery);\n  }\n})(function ($) {\n\n  'use strict';\n\n  // Globals\n  var $window = $(window);\n  var $document = $(document);\n  var location = window.location;\n  var navigator = window.navigator;\n  var ArrayBuffer = window.ArrayBuffer;\n  var Uint8Array = window.Uint8Array;\n  var DataView = window.DataView;\n  var btoa = window.btoa;\n\n  // Constants\n  var NAMESPACE = 'cropper';\n\n  // Classes\n  var CLASS_MODAL = 'cropper-modal';\n  var CLASS_HIDE = 'cropper-hide';\n  var CLASS_HIDDEN = 'cropper-hidden';\n  var CLASS_INVISIBLE = 'cropper-invisible';\n  var CLASS_MOVE = 'cropper-move';\n  var CLASS_CROP = 'cropper-crop';\n  var CLASS_DISABLED = 'cropper-disabled';\n  var CLASS_BG = 'cropper-bg';\n\n  // Events\n  var EVENT_MOUSE_DOWN = 'mousedown touchstart pointerdown MSPointerDown';\n  var EVENT_MOUSE_MOVE = 'mousemove touchmove pointermove MSPointerMove';\n  var EVENT_MOUSE_UP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';\n  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_LOAD = 'load.' + NAMESPACE;\n  var EVENT_ERROR = 'error.' + NAMESPACE;\n  var EVENT_RESIZE = 'resize.' + NAMESPACE; // Bind to window with namespace\n  var EVENT_BUILD = 'build.' + NAMESPACE;\n  var EVENT_BUILT = 'built.' + NAMESPACE;\n  var EVENT_CROP_START = 'cropstart.' + NAMESPACE;\n  var EVENT_CROP_MOVE = 'cropmove.' + NAMESPACE;\n  var EVENT_CROP_END = 'cropend.' + NAMESPACE;\n  var EVENT_CROP = 'crop.' + NAMESPACE;\n  var EVENT_ZOOM = 'zoom.' + NAMESPACE;\n\n  // RegExps\n  var REGEXP_ACTIONS = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/;\n  var REGEXP_DATA_URL = /^data\\:/;\n  var REGEXP_DATA_URL_HEAD = /^data\\:([^\\;]+)\\;base64,/;\n  var REGEXP_DATA_URL_JPEG = /^data\\:image\\/jpeg.*;base64,/;\n\n  // Data keys\n  var DATA_PREVIEW = 'preview';\n  var DATA_ACTION = 'action';\n\n  // Actions\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_NONE = 'none';\n\n  // Supports\n  var SUPPORT_CANVAS = $.isFunction($('<canvas>')[0].getContext);\n  var IS_SAFARI = navigator && /safari/i.test(navigator.userAgent) && /apple computer/i.test(navigator.vendor);\n\n  // Maths\n  var num = Number;\n  var min = Math.min;\n  var max = Math.max;\n  var abs = Math.abs;\n  var sin = Math.sin;\n  var cos = Math.cos;\n  var sqrt = Math.sqrt;\n  var round = Math.round;\n  var floor = Math.floor;\n\n  // Utilities\n  var fromCharCode = String.fromCharCode;\n\n  function isNumber(n) {\n    return typeof n === 'number' && !isNaN(n);\n  }\n\n  function isUndefined(n) {\n    return typeof n === 'undefined';\n  }\n\n  function toArray(obj, offset) {\n    var args = [];\n\n    // This is necessary for IE8\n    if (isNumber(offset)) {\n      args.push(offset);\n    }\n\n    return args.slice.apply(obj, args);\n  }\n\n  // Custom proxy to avoid jQuery's guid\n  function proxy(fn, context) {\n    var args = toArray(arguments, 2);\n\n    return function () {\n      return fn.apply(context, args.concat(toArray(arguments)));\n    };\n  }\n\n  function isCrossOriginURL(url) {\n    var parts = url.match(/^(https?:)\\/\\/([^\\:\\/\\?#]+):?(\\d*)/i);\n\n    return parts && (\n      parts[1] !== location.protocol ||\n      parts[2] !== location.hostname ||\n      parts[3] !== location.port\n    );\n  }\n\n  function addTimestamp(url) {\n    var timestamp = 'timestamp=' + (new Date()).getTime();\n\n    return (url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp);\n  }\n\n  function getCrossOrigin(crossOrigin) {\n    return crossOrigin ? ' crossOrigin=\"' + crossOrigin + '\"' : '';\n  }\n\n  function getImageSize(image, callback) {\n    var newImage;\n\n    // Modern browsers (ignore Safari, #120 & #509)\n    if (image.naturalWidth && !IS_SAFARI) {\n      return callback(image.naturalWidth, image.naturalHeight);\n    }\n\n    // IE8: Don't use `new Image()` here (#319)\n    newImage = document.createElement('img');\n\n    newImage.onload = function () {\n      callback(this.width, this.height);\n    };\n\n    newImage.src = image.src;\n  }\n\n  function getTransform(options) {\n    var transforms = [];\n    var rotate = options.rotate;\n    var scaleX = options.scaleX;\n    var scaleY = options.scaleY;\n\n    if (isNumber(rotate)) {\n      transforms.push('rotate(' + rotate + 'deg)');\n    }\n\n    if (isNumber(scaleX) && isNumber(scaleY)) {\n      transforms.push('scale(' + scaleX + ',' + scaleY + ')');\n    }\n\n    return transforms.length ? transforms.join(' ') : 'none';\n  }\n\n  function getRotatedSizes(data, isReversed) {\n    var deg = abs(data.degree) % 180;\n    var arc = (deg > 90 ? (180 - deg) : deg) * Math.PI / 180;\n    var sinArc = sin(arc);\n    var cosArc = cos(arc);\n    var width = data.width;\n    var height = data.height;\n    var aspectRatio = data.aspectRatio;\n    var newWidth;\n    var newHeight;\n\n    if (!isReversed) {\n      newWidth = width * cosArc + height * sinArc;\n      newHeight = width * sinArc + height * cosArc;\n    } else {\n      newWidth = width / (cosArc + sinArc / aspectRatio);\n      newHeight = newWidth / aspectRatio;\n    }\n\n    return {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  function getSourceCanvas(image, data) {\n    var canvas = $('<canvas>')[0];\n    var context = canvas.getContext('2d');\n    var dstX = 0;\n    var dstY = 0;\n    var dstWidth = data.naturalWidth;\n    var dstHeight = data.naturalHeight;\n    var rotate = data.rotate;\n    var scaleX = data.scaleX;\n    var scaleY = data.scaleY;\n    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);\n    var rotatable = isNumber(rotate) && rotate !== 0;\n    var advanced = rotatable || scalable;\n    var canvasWidth = dstWidth * abs(scaleX || 1);\n    var canvasHeight = dstHeight * abs(scaleY || 1);\n    var translateX;\n    var translateY;\n    var rotated;\n\n    if (scalable) {\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    if (rotatable) {\n      rotated = getRotatedSizes({\n        width: canvasWidth,\n        height: canvasHeight,\n        degree: rotate\n      });\n\n      canvasWidth = rotated.width;\n      canvasHeight = rotated.height;\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    if (advanced) {\n      dstX = -dstWidth / 2;\n      dstY = -dstHeight / 2;\n\n      context.save();\n      context.translate(translateX, translateY);\n    }\n\n    if (rotatable) {\n      context.rotate(rotate * Math.PI / 180);\n    }\n\n    // Should call `scale` after rotated\n    if (scalable) {\n      context.scale(scaleX, scaleY);\n    }\n\n    context.drawImage(image, floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n\n    if (advanced) {\n      context.restore();\n    }\n\n    return canvas;\n  }\n\n  function getTouchesCenter(touches) {\n    var length = touches.length;\n    var pageX = 0;\n    var pageY = 0;\n\n    if (length) {\n      $.each(touches, function (i, touch) {\n        pageX += touch.pageX;\n        pageY += touch.pageY;\n      });\n\n      pageX /= length;\n      pageY /= length;\n    }\n\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    var i;\n\n    for (i = start, length += start; i < length; i++) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n\n    return str;\n  }\n\n  function getOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var length = dataView.byteLength;\n    var orientation;\n    var exifIDCode;\n    var tiffOffset;\n    var firstIFDOffset;\n    var littleEndian;\n    var endianness;\n    var app1Start;\n    var ifdStart;\n    var offset;\n    var i;\n\n    // Only handle JPEG image (start by 0xFFD8)\n    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n      offset = 2;\n\n      while (offset < length) {\n        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n          app1Start = offset;\n          break;\n        }\n\n        offset++;\n      }\n    }\n\n    if (app1Start) {\n      exifIDCode = app1Start + 4;\n      tiffOffset = app1Start + 10;\n\n      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n        endianness = dataView.getUint16(tiffOffset);\n        littleEndian = endianness === 0x4949;\n\n        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n      }\n    }\n\n    if (ifdStart) {\n      length = dataView.getUint16(ifdStart, littleEndian);\n\n      for (i = 0; i < length; i++) {\n        offset = ifdStart + i * 12 + 2;\n\n        if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {\n\n          // 8 is the offset of the current tag's value\n          offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(offset, littleEndian);\n\n          // Override the orientation with its default value for Safari (#120)\n          if (IS_SAFARI) {\n            dataView.setUint16(offset, 1, littleEndian);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return orientation;\n  }\n\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var length = binary.length;\n    var arrayBuffer = new ArrayBuffer(length);\n    var dataView = new Uint8Array(arrayBuffer);\n    var i;\n\n    for (i = 0; i < length; i++) {\n      dataView[i] = binary.charCodeAt(i);\n    }\n\n    return arrayBuffer;\n  }\n\n  // Only available for JPEG image\n  function arrayBufferToDataURL(arrayBuffer) {\n    var dataView = new Uint8Array(arrayBuffer);\n    var length = dataView.length;\n    var base64 = '';\n    var i;\n\n    for (i = 0; i < length; i++) {\n      base64 += fromCharCode(dataView[i]);\n    }\n\n    return 'data:image/jpeg;base64,' + btoa(base64);\n  }\n\n  function Cropper(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, Cropper.DEFAULTS, $.isPlainObject(options) && options);\n    this.isLoaded = false;\n    this.isBuilt = false;\n    this.isCompleted = false;\n    this.isRotated = false;\n    this.isCropped = false;\n    this.isDisabled = false;\n    this.isReplaced = false;\n    this.isLimited = false;\n    this.wheeling = false;\n    this.isImg = false;\n    this.originalUrl = '';\n    this.canvas = null;\n    this.cropBox = null;\n    this.init();\n  }\n\n  Cropper.prototype = {\n    constructor: Cropper,\n\n    init: function () {\n      var $this = this.$element;\n      var url;\n\n      if ($this.is('img')) {\n        this.isImg = true;\n\n        // Should use `$.fn.attr` here. e.g.: \"img/picture.jpg\"\n        this.originalUrl = url = $this.attr('src');\n\n        // Stop when it's a blank image\n        if (!url) {\n          return;\n        }\n\n        // Should use `$.fn.prop` here. e.g.: \"http://example.com/img/picture.jpg\"\n        url = $this.prop('src');\n      } else if ($this.is('canvas') && SUPPORT_CANVAS) {\n        url = $this[0].toDataURL();\n      }\n\n      this.load(url);\n    },\n\n    // A shortcut for triggering custom events\n    trigger: function (type, data) {\n      var e = $.Event(type, data);\n\n      this.$element.trigger(e);\n\n      return e;\n    },\n\n    load: function (url) {\n      var options = this.options;\n      var $this = this.$element;\n      var read;\n      var xhr;\n\n      if (!url) {\n        return;\n      }\n\n      // Trigger build event first\n      $this.one(EVENT_BUILD, options.build);\n\n      if (this.trigger(EVENT_BUILD).isDefaultPrevented()) {\n        return;\n      }\n\n      this.url = url;\n      this.image = {};\n\n      if (!options.checkOrientation || !ArrayBuffer) {\n        return this.clone();\n      }\n\n      read = $.proxy(this.read, this);\n\n      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari\n      if (REGEXP_DATA_URL.test(url)) {\n        return REGEXP_DATA_URL_JPEG.test(url) ?\n          read(dataURLToArrayBuffer(url)) :\n          this.clone();\n      }\n\n      xhr = new XMLHttpRequest();\n\n      xhr.onerror = xhr.onabort = $.proxy(function () {\n        this.clone();\n      }, this);\n\n      xhr.onload = function () {\n        read(this.response);\n      };\n\n      xhr.open('get', url);\n      xhr.responseType = 'arraybuffer';\n      xhr.send();\n    },\n\n    read: function (arrayBuffer) {\n      var options = this.options;\n      var orientation = getOrientation(arrayBuffer);\n      var image = this.image;\n      var rotate;\n      var scaleX;\n      var scaleY;\n\n      if (orientation > 1) {\n        this.url = arrayBufferToDataURL(arrayBuffer);\n\n        switch (orientation) {\n\n          // flip horizontal\n          case 2:\n            scaleX = -1;\n            break;\n\n          // rotate left 180°\n          case 3:\n            rotate = -180;\n            break;\n\n          // flip vertical\n          case 4:\n            scaleY = -1;\n            break;\n\n          // flip vertical + rotate right 90°\n          case 5:\n            rotate = 90;\n            scaleY = -1;\n            break;\n\n          // rotate right 90°\n          case 6:\n            rotate = 90;\n            break;\n\n          // flip horizontal + rotate right 90°\n          case 7:\n            rotate = 90;\n            scaleX = -1;\n            break;\n\n          // rotate left 90°\n          case 8:\n            rotate = -90;\n            break;\n        }\n      }\n\n      if (options.rotatable) {\n        image.rotate = rotate;\n      }\n\n      if (options.scalable) {\n        image.scaleX = scaleX;\n        image.scaleY = scaleY;\n      }\n\n      this.clone();\n    },\n\n    clone: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var url = this.url;\n      var crossOrigin = '';\n      var crossOriginUrl;\n      var $clone;\n\n      if (options.checkCrossOrigin && isCrossOriginURL(url)) {\n        crossOrigin = $this.prop('crossOrigin');\n\n        if (crossOrigin) {\n          crossOriginUrl = url;\n        } else {\n          crossOrigin = 'anonymous';\n\n          // Bust cache (#148) when there is not a \"crossOrigin\" property\n          crossOriginUrl = addTimestamp(url);\n        }\n      }\n\n      this.crossOrigin = crossOrigin;\n      this.crossOriginUrl = crossOriginUrl;\n      this.$clone = $clone = $('<img' + getCrossOrigin(crossOrigin) + ' src=\"' + (crossOriginUrl || url) + '\">');\n\n      if (this.isImg) {\n        if ($this[0].complete) {\n          this.start();\n        } else {\n          $this.one(EVENT_LOAD, $.proxy(this.start, this));\n        }\n      } else {\n        $clone.\n          one(EVENT_LOAD, $.proxy(this.start, this)).\n          one(EVENT_ERROR, $.proxy(this.stop, this)).\n          addClass(CLASS_HIDE).\n          insertAfter($this);\n      }\n    },\n\n    start: function () {\n      var $image = this.$element;\n      var $clone = this.$clone;\n\n      if (!this.isImg) {\n        $clone.off(EVENT_ERROR, this.stop);\n        $image = $clone;\n      }\n\n      getImageSize($image[0], $.proxy(function (naturalWidth, naturalHeight) {\n        $.extend(this.image, {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight,\n          aspectRatio: naturalWidth / naturalHeight\n        });\n\n        this.isLoaded = true;\n        this.build();\n      }, this));\n    },\n\n    stop: function () {\n      this.$clone.remove();\n      this.$clone = null;\n    },\n\n    build: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $clone = this.$clone;\n      var $cropper;\n      var $cropBox;\n      var $face;\n\n      if (!this.isLoaded) {\n        return;\n      }\n\n      // Unbuild first when replace\n      if (this.isBuilt) {\n        this.unbuild();\n      }\n\n      // Create cropper elements\n      this.$container = $this.parent();\n      this.$cropper = $cropper = $(Cropper.TEMPLATE);\n      this.$canvas = $cropper.find('.cropper-canvas').append($clone);\n      this.$dragBox = $cropper.find('.cropper-drag-box');\n      this.$cropBox = $cropBox = $cropper.find('.cropper-crop-box');\n      this.$viewBox = $cropper.find('.cropper-view-box');\n      this.$face = $face = $cropBox.find('.cropper-face');\n\n      // Hide the original image\n      $this.addClass(CLASS_HIDDEN).after($cropper);\n\n      // Show the clone image if is hidden\n      if (!this.isImg) {\n        $clone.removeClass(CLASS_HIDE);\n      }\n\n      this.initPreview();\n      this.bind();\n\n      options.aspectRatio = max(0, options.aspectRatio) || NaN;\n      options.viewMode = max(0, min(3, round(options.viewMode))) || 0;\n\n      if (options.autoCrop) {\n        this.isCropped = true;\n\n        if (options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      } else {\n        $cropBox.addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.guides) {\n        $cropBox.find('.cropper-dashed').addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.center) {\n        $cropBox.find('.cropper-center').addClass(CLASS_HIDDEN);\n      }\n\n      if (options.cropBoxMovable) {\n        $face.addClass(CLASS_MOVE).data(DATA_ACTION, ACTION_ALL);\n      }\n\n      if (!options.highlight) {\n        $face.addClass(CLASS_INVISIBLE);\n      }\n\n      if (options.background) {\n        $cropper.addClass(CLASS_BG);\n      }\n\n      if (!options.cropBoxResizable) {\n        $cropBox.find('.cropper-line, .cropper-point').addClass(CLASS_HIDDEN);\n      }\n\n      this.setDragMode(options.dragMode);\n      this.render();\n      this.isBuilt = true;\n      this.setData(options.data);\n      $this.one(EVENT_BUILT, options.built);\n\n      // Trigger the built event asynchronously to keep `data('cropper')` is defined\n      setTimeout($.proxy(function () {\n        this.trigger(EVENT_BUILT);\n        this.isCompleted = true;\n      }, this), 0);\n    },\n\n    unbuild: function () {\n      if (!this.isBuilt) {\n        return;\n      }\n\n      this.isBuilt = false;\n      this.isCompleted = false;\n      this.initialImage = null;\n\n      // Clear `initialCanvas` is necessary when replace\n      this.initialCanvas = null;\n      this.initialCropBox = null;\n      this.container = null;\n      this.canvas = null;\n\n      // Clear `cropBox` is necessary when replace\n      this.cropBox = null;\n      this.unbind();\n\n      this.resetPreview();\n      this.$preview = null;\n\n      this.$viewBox = null;\n      this.$cropBox = null;\n      this.$dragBox = null;\n      this.$canvas = null;\n      this.$container = null;\n\n      this.$cropper.remove();\n      this.$cropper = null;\n    },\n\n    render: function () {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    initContainer: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $container = this.$container;\n      var $cropper = this.$cropper;\n\n      $cropper.addClass(CLASS_HIDDEN);\n      $this.removeClass(CLASS_HIDDEN);\n\n      $cropper.css((this.container = {\n        width: max($container.width(), num(options.minContainerWidth) || 200),\n        height: max($container.height(), num(options.minContainerHeight) || 100)\n      }));\n\n      $this.addClass(CLASS_HIDDEN);\n      $cropper.removeClass(CLASS_HIDDEN);\n    },\n\n    // Canvas (image wrapper)\n    initCanvas: function () {\n      var viewMode = this.options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var image = this.image;\n      var imageNaturalWidth = image.naturalWidth;\n      var imageNaturalHeight = image.naturalHeight;\n      var is90Degree = abs(image.rotate) === 90;\n      var naturalWidth = is90Degree ? imageNaturalHeight : imageNaturalWidth;\n      var naturalHeight = is90Degree ? imageNaturalWidth : imageNaturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerWidth;\n      var canvasHeight = containerHeight;\n      var canvas;\n\n      if (containerHeight * aspectRatio > containerWidth) {\n        if (viewMode === 3) {\n          canvasWidth = containerHeight * aspectRatio;\n        } else {\n          canvasHeight = containerWidth / aspectRatio;\n        }\n      } else {\n        if (viewMode === 3) {\n          canvasHeight = containerWidth / aspectRatio;\n        } else {\n          canvasWidth = containerHeight * aspectRatio;\n        }\n      }\n\n      canvas = {\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        aspectRatio: aspectRatio,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n\n      canvas.oldLeft = canvas.left = (containerWidth - canvasWidth) / 2;\n      canvas.oldTop = canvas.top = (containerHeight - canvasHeight) / 2;\n\n      this.canvas = canvas;\n      this.isLimited = (viewMode === 1 || viewMode === 2);\n      this.limitCanvas(true, true);\n      this.initialImage = $.extend({}, image);\n      this.initialCanvas = $.extend({}, canvas);\n    },\n\n    limitCanvas: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var viewMode = options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n      var cropBox = this.cropBox;\n      var isCropped = this.isCropped && cropBox;\n      var minCanvasWidth;\n      var minCanvasHeight;\n      var newCanvasLeft;\n      var newCanvasTop;\n\n      if (isSizeLimited) {\n        minCanvasWidth = num(options.minCanvasWidth) || 0;\n        minCanvasHeight = num(options.minCanvasHeight) || 0;\n\n        if (viewMode) {\n          if (viewMode > 1) {\n            minCanvasWidth = max(minCanvasWidth, containerWidth);\n            minCanvasHeight = max(minCanvasHeight, containerHeight);\n\n            if (viewMode === 3) {\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          } else {\n            if (minCanvasWidth) {\n              minCanvasWidth = max(minCanvasWidth, isCropped ? cropBox.width : 0);\n            } else if (minCanvasHeight) {\n              minCanvasHeight = max(minCanvasHeight, isCropped ? cropBox.height : 0);\n            } else if (isCropped) {\n              minCanvasWidth = cropBox.width;\n              minCanvasHeight = cropBox.height;\n\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          }\n        }\n\n        if (minCanvasWidth && minCanvasHeight) {\n          if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n            minCanvasHeight = minCanvasWidth / aspectRatio;\n          } else {\n            minCanvasWidth = minCanvasHeight * aspectRatio;\n          }\n        } else if (minCanvasWidth) {\n          minCanvasHeight = minCanvasWidth / aspectRatio;\n        } else if (minCanvasHeight) {\n          minCanvasWidth = minCanvasHeight * aspectRatio;\n        }\n\n        canvas.minWidth = minCanvasWidth;\n        canvas.minHeight = minCanvasHeight;\n        canvas.maxWidth = Infinity;\n        canvas.maxHeight = Infinity;\n      }\n\n      if (isPositionLimited) {\n        if (viewMode) {\n          newCanvasLeft = containerWidth - canvas.width;\n          newCanvasTop = containerHeight - canvas.height;\n\n          canvas.minLeft = min(0, newCanvasLeft);\n          canvas.minTop = min(0, newCanvasTop);\n          canvas.maxLeft = max(0, newCanvasLeft);\n          canvas.maxTop = max(0, newCanvasTop);\n\n          if (isCropped && this.isLimited) {\n            canvas.minLeft = min(\n              cropBox.left,\n              cropBox.left + cropBox.width - canvas.width\n            );\n            canvas.minTop = min(\n              cropBox.top,\n              cropBox.top + cropBox.height - canvas.height\n            );\n            canvas.maxLeft = cropBox.left;\n            canvas.maxTop = cropBox.top;\n\n            if (viewMode === 2) {\n              if (canvas.width >= containerWidth) {\n                canvas.minLeft = min(0, newCanvasLeft);\n                canvas.maxLeft = max(0, newCanvasLeft);\n              }\n\n              if (canvas.height >= containerHeight) {\n                canvas.minTop = min(0, newCanvasTop);\n                canvas.maxTop = max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvas.minLeft = -canvas.width;\n          canvas.minTop = -canvas.height;\n          canvas.maxLeft = containerWidth;\n          canvas.maxTop = containerHeight;\n        }\n      }\n    },\n\n    renderCanvas: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var rotate = image.rotate;\n      var naturalWidth = image.naturalWidth;\n      var naturalHeight = image.naturalHeight;\n      var aspectRatio;\n      var rotated;\n\n      if (this.isRotated) {\n        this.isRotated = false;\n\n        // Computes rotated sizes with image sizes\n        rotated = getRotatedSizes({\n          width: image.width,\n          height: image.height,\n          degree: rotate\n        });\n\n        aspectRatio = rotated.width / rotated.height;\n\n        if (aspectRatio !== canvas.aspectRatio) {\n          canvas.left -= (rotated.width - canvas.width) / 2;\n          canvas.top -= (rotated.height - canvas.height) / 2;\n          canvas.width = rotated.width;\n          canvas.height = rotated.height;\n          canvas.aspectRatio = aspectRatio;\n          canvas.naturalWidth = naturalWidth;\n          canvas.naturalHeight = naturalHeight;\n\n          // Computes rotated sizes with natural image sizes\n          if (rotate % 180) {\n            rotated = getRotatedSizes({\n              width: naturalWidth,\n              height: naturalHeight,\n              degree: rotate\n            });\n\n            canvas.naturalWidth = rotated.width;\n            canvas.naturalHeight = rotated.height;\n          }\n\n          this.limitCanvas(true, false);\n        }\n      }\n\n      if (canvas.width > canvas.maxWidth || canvas.width < canvas.minWidth) {\n        canvas.left = canvas.oldLeft;\n      }\n\n      if (canvas.height > canvas.maxHeight || canvas.height < canvas.minHeight) {\n        canvas.top = canvas.oldTop;\n      }\n\n      canvas.width = min(max(canvas.width, canvas.minWidth), canvas.maxWidth);\n      canvas.height = min(max(canvas.height, canvas.minHeight), canvas.maxHeight);\n\n      this.limitCanvas(false, true);\n\n      canvas.oldLeft = canvas.left = min(max(canvas.left, canvas.minLeft), canvas.maxLeft);\n      canvas.oldTop = canvas.top = min(max(canvas.top, canvas.minTop), canvas.maxTop);\n\n      this.$canvas.css({\n        width: canvas.width,\n        height: canvas.height,\n        left: canvas.left,\n        top: canvas.top\n      });\n\n      this.renderImage();\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCropBox(true, true);\n      }\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    renderImage: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var reversed;\n\n      if (image.rotate) {\n        reversed = getRotatedSizes({\n          width: canvas.width,\n          height: canvas.height,\n          degree: image.rotate,\n          aspectRatio: image.aspectRatio\n        }, true);\n      }\n\n      $.extend(image, reversed ? {\n        width: reversed.width,\n        height: reversed.height,\n        left: (canvas.width - reversed.width) / 2,\n        top: (canvas.height - reversed.height) / 2\n      } : {\n        width: canvas.width,\n        height: canvas.height,\n        left: 0,\n        top: 0\n      });\n\n      this.$clone.css({\n        width: image.width,\n        height: image.height,\n        marginLeft: image.left,\n        marginTop: image.top,\n        transform: getTransform(image)\n      });\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    initCropBox: function () {\n      var options = this.options;\n      var canvas = this.canvas;\n      var aspectRatio = options.aspectRatio;\n      var autoCropArea = num(options.autoCropArea) || 0.8;\n      var cropBox = {\n            width: canvas.width,\n            height: canvas.height\n          };\n\n      if (aspectRatio) {\n        if (canvas.height * aspectRatio > canvas.width) {\n          cropBox.height = cropBox.width / aspectRatio;\n        } else {\n          cropBox.width = cropBox.height * aspectRatio;\n        }\n      }\n\n      this.cropBox = cropBox;\n      this.limitCropBox(true, true);\n\n      // Initialize auto crop area\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      // The width of auto crop area must large than \"minWidth\", and the height too. (#164)\n      cropBox.width = max(cropBox.minWidth, cropBox.width * autoCropArea);\n      cropBox.height = max(cropBox.minHeight, cropBox.height * autoCropArea);\n      cropBox.oldLeft = cropBox.left = canvas.left + (canvas.width - cropBox.width) / 2;\n      cropBox.oldTop = cropBox.top = canvas.top + (canvas.height - cropBox.height) / 2;\n\n      this.initialCropBox = $.extend({}, cropBox);\n    },\n\n    limitCropBox: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var isLimited = this.isLimited;\n      var minCropBoxWidth;\n      var minCropBoxHeight;\n      var maxCropBoxWidth;\n      var maxCropBoxHeight;\n\n      if (isSizeLimited) {\n        minCropBoxWidth = num(options.minCropBoxWidth) || 0;\n        minCropBoxHeight = num(options.minCropBoxHeight) || 0;\n\n        // The min/maxCropBoxWidth/Height must be less than containerWidth/Height\n        minCropBoxWidth = min(minCropBoxWidth, containerWidth);\n        minCropBoxHeight = min(minCropBoxHeight, containerHeight);\n        maxCropBoxWidth = min(containerWidth, isLimited ? canvas.width : containerWidth);\n        maxCropBoxHeight = min(containerHeight, isLimited ? canvas.height : containerHeight);\n\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        }\n\n        // The minWidth/Height must be less than maxWidth/Height\n        cropBox.minWidth = min(minCropBoxWidth, maxCropBoxWidth);\n        cropBox.minHeight = min(minCropBoxHeight, maxCropBoxHeight);\n        cropBox.maxWidth = maxCropBoxWidth;\n        cropBox.maxHeight = maxCropBoxHeight;\n      }\n\n      if (isPositionLimited) {\n        if (isLimited) {\n          cropBox.minLeft = max(0, canvas.left);\n          cropBox.minTop = max(0, canvas.top);\n          cropBox.maxLeft = min(containerWidth, canvas.left + canvas.width) - cropBox.width;\n          cropBox.maxTop = min(containerHeight, canvas.top + canvas.height) - cropBox.height;\n        } else {\n          cropBox.minLeft = 0;\n          cropBox.minTop = 0;\n          cropBox.maxLeft = containerWidth - cropBox.width;\n          cropBox.maxTop = containerHeight - cropBox.height;\n        }\n      }\n    },\n\n    renderCropBox: function () {\n      var options = this.options;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var cropBox = this.cropBox;\n\n      if (cropBox.width > cropBox.maxWidth || cropBox.width < cropBox.minWidth) {\n        cropBox.left = cropBox.oldLeft;\n      }\n\n      if (cropBox.height > cropBox.maxHeight || cropBox.height < cropBox.minHeight) {\n        cropBox.top = cropBox.oldTop;\n      }\n\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      this.limitCropBox(false, true);\n\n      cropBox.oldLeft = cropBox.left = min(max(cropBox.left, cropBox.minLeft), cropBox.maxLeft);\n      cropBox.oldTop = cropBox.top = min(max(cropBox.top, cropBox.minTop), cropBox.maxTop);\n\n      if (options.movable && options.cropBoxMovable) {\n\n        // Turn to move the canvas when the crop box is equal to the container\n        this.$face.data(DATA_ACTION, (cropBox.width === containerWidth && cropBox.height === containerHeight) ? ACTION_MOVE : ACTION_ALL);\n      }\n\n      this.$cropBox.css({\n        width: cropBox.width,\n        height: cropBox.height,\n        left: cropBox.left,\n        top: cropBox.top\n      });\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCanvas(true, true);\n      }\n\n      if (!this.isDisabled) {\n        this.output();\n      }\n    },\n\n    output: function () {\n      this.preview();\n\n      if (this.isCompleted) {\n        this.trigger(EVENT_CROP, this.getData());\n      } else if (!this.isBuilt) {\n\n        // Only trigger one crop event before complete\n        this.$element.one(EVENT_BUILT, $.proxy(function () {\n          this.trigger(EVENT_CROP, this.getData());\n        }, this));\n      }\n    },\n\n    initPreview: function () {\n      var crossOrigin = getCrossOrigin(this.crossOrigin);\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var $clone2;\n\n      this.$preview = $(this.options.preview);\n      this.$clone2 = $clone2 = $('<img' + crossOrigin + ' src=\"' + url + '\">');\n      this.$viewBox.html($clone2);\n      this.$preview.each(function () {\n        var $this = $(this);\n\n        // Save the original size for recover\n        $this.data(DATA_PREVIEW, {\n          width: $this.width(),\n          height: $this.height(),\n          html: $this.html()\n        });\n\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * (Occur only when margin-top <= -height)\n         */\n        $this.html(\n          '<img' + crossOrigin + ' src=\"' + url + '\" style=\"' +\n          'display:block;width:100%;height:auto;' +\n          'min-width:0!important;min-height:0!important;' +\n          'max-width:none!important;max-height:none!important;' +\n          'image-orientation:0deg!important;\">'\n        );\n      });\n    },\n\n    resetPreview: function () {\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n\n        $this.css({\n          width: data.width,\n          height: data.height\n        }).html(data.html).removeData(DATA_PREVIEW);\n      });\n    },\n\n    preview: function () {\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var cropBoxWidth = cropBox.width;\n      var cropBoxHeight = cropBox.height;\n      var width = image.width;\n      var height = image.height;\n      var left = cropBox.left - canvas.left - image.left;\n      var top = cropBox.top - canvas.top - image.top;\n\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      this.$clone2.css({\n        width: width,\n        height: height,\n        marginLeft: -left,\n        marginTop: -top,\n        transform: getTransform(image)\n      });\n\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n\n        $this.css({\n          width: newWidth,\n          height: newHeight\n        }).find('img').css({\n          width: width * ratio,\n          height: height * ratio,\n          marginLeft: -left * ratio,\n          marginTop: -top * ratio,\n          transform: getTransform(image)\n        });\n      });\n    },\n\n    bind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.on(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.on(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.on(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.on(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.on(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.on(EVENT_MOUSE_DOWN, $.proxy(this.cropStart, this));\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.on(EVENT_WHEEL, $.proxy(this.wheel, this));\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.on(EVENT_DBLCLICK, $.proxy(this.dblclick, this));\n      }\n\n      $document.\n        on(EVENT_MOUSE_MOVE, (this._cropMove = proxy(this.cropMove, this))).\n        on(EVENT_MOUSE_UP, (this._cropEnd = proxy(this.cropEnd, this)));\n\n      if (options.responsive) {\n        $window.on(EVENT_RESIZE, (this._resize = proxy(this.resize, this)));\n      }\n    },\n\n    unbind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.off(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.off(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.off(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.off(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.off(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.off(EVENT_MOUSE_DOWN, this.cropStart);\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.off(EVENT_WHEEL, this.wheel);\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.off(EVENT_DBLCLICK, this.dblclick);\n      }\n\n      $document.\n        off(EVENT_MOUSE_MOVE, this._cropMove).\n        off(EVENT_MOUSE_UP, this._cropEnd);\n\n      if (options.responsive) {\n        $window.off(EVENT_RESIZE, this._resize);\n      }\n    },\n\n    resize: function () {\n      var restore = this.options.restore;\n      var $container = this.$container;\n      var container = this.container;\n      var canvasData;\n      var cropBoxData;\n      var ratio;\n\n      // Check `container` is necessary for IE8\n      if (this.isDisabled || !container) {\n        return;\n      }\n\n      ratio = $container.width() / container.width;\n\n      // Resize when width changed or height changed\n      if (ratio !== 1 || $container.height() !== container.height) {\n        if (restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n\n        this.render();\n\n        if (restore) {\n          this.setCanvasData($.each(canvasData, function (i, n) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData($.each(cropBoxData, function (i, n) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n\n    dblclick: function () {\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (this.$dragBox.hasClass(CLASS_CROP)) {\n        this.setDragMode(ACTION_MOVE);\n      } else {\n        this.setDragMode(ACTION_CROP);\n      }\n    },\n\n    wheel: function (event) {\n      var e = event.originalEvent || event;\n      var ratio = num(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      event.preventDefault();\n\n      // Limit wheel speed to prevent zoom too fast\n      if (this.wheeling) {\n        return;\n      }\n\n      this.wheeling = true;\n\n      setTimeout($.proxy(function () {\n        this.wheeling = false;\n      }, this), 50);\n\n      if (e.deltaY) {\n        delta = e.deltaY > 0 ? 1 : -1;\n      } else if (e.wheelDelta) {\n        delta = -e.wheelDelta / 120;\n      } else if (e.detail) {\n        delta = e.detail > 0 ? 1 : -1;\n      }\n\n      this.zoom(-delta * ratio, event);\n    },\n\n    cropStart: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var touchesLength;\n      var action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.startX2 = e.pageX;\n            this.startY2 = e.pageY;\n            action = ACTION_ZOOM;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      action = action || $(e.target).data(DATA_ACTION);\n\n      if (REGEXP_ACTIONS.test(action)) {\n        if (this.trigger(EVENT_CROP_START, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.action = action;\n        this.cropping = false;\n\n        // IE8  has `event.pageX/Y`, but not `event.originalEvent.pageX/Y`\n        // IE10 has `event.originalEvent.pageX/Y`, but not `event.pageX/Y`\n        this.startX = e.pageX || originalEvent && originalEvent.pageX;\n        this.startY = e.pageY || originalEvent && originalEvent.pageY;\n\n        if (action === ACTION_CROP) {\n          this.cropping = true;\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      }\n    },\n\n    cropMove: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var action = this.action;\n      var touchesLength;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.endX2 = e.pageX;\n            this.endY2 = e.pageY;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      if (action) {\n        if (this.trigger(EVENT_CROP_MOVE, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.endX = e.pageX || originalEvent && originalEvent.pageX;\n        this.endY = e.pageY || originalEvent && originalEvent.pageY;\n\n        this.change(e.shiftKey, action === ACTION_ZOOM ? event : null);\n      }\n    },\n\n    cropEnd: function (event) {\n      var originalEvent = event.originalEvent;\n      var action = this.action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (action) {\n        event.preventDefault();\n\n        if (this.cropping) {\n          this.cropping = false;\n          this.$dragBox.toggleClass(CLASS_MODAL, this.isCropped && this.options.modal);\n        }\n\n        this.action = '';\n\n        this.trigger(EVENT_CROP_END, {\n          originalEvent: originalEvent,\n          action: action\n        });\n      }\n    },\n\n    change: function (shiftKey, event) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var action = this.action;\n      var container = this.container;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var width = cropBox.width;\n      var height = cropBox.height;\n      var left = cropBox.left;\n      var top = cropBox.top;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = container.width;\n      var maxHeight = container.height;\n      var renderable = true;\n      var offset;\n      var range;\n\n      // Locking aspect ratio in \"free mode\" by holding shift key (#259)\n      if (!aspectRatio && shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n\n      if (this.limited) {\n        minLeft = cropBox.minLeft;\n        minTop = cropBox.minTop;\n        maxWidth = minLeft + min(container.width, canvas.left + canvas.width);\n        maxHeight = minTop + min(container.height, canvas.top + canvas.height);\n      }\n\n      range = {\n        x: this.endX - this.startX,\n        y: this.endY - this.startY\n      };\n\n      if (aspectRatio) {\n        range.X = range.y * aspectRatio;\n        range.Y = range.x / aspectRatio;\n      }\n\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n\n        // Resize crop box\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top -= range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height -= range.y;\n          top += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width -= range.x;\n          left += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left -= range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += range.X;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        // Move canvas\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n\n        // Zoom canvas\n        case ACTION_ZOOM:\n          this.zoom((function (x1, y1, x2, y2) {\n            var z1 = sqrt(x1 * x1 + y1 * y1);\n            var z2 = sqrt(x2 * x2 + y2 * y2);\n\n            return (z2 - z1) / z1;\n          })(\n            abs(this.startX - this.startX2),\n            abs(this.startY - this.startY2),\n            abs(this.endX - this.endX2),\n            abs(this.endY - this.endY2)\n          ), event);\n          this.startX2 = this.endX2;\n          this.startY2 = this.endY2;\n          renderable = false;\n          break;\n\n        // Create crop box\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n\n          offset = this.$cropper.offset();\n          left = this.startX - offset.left;\n          top = this.startY - offset.top;\n          width = cropBox.minWidth;\n          height = cropBox.minHeight;\n\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n\n          if (range.y < 0) {\n            top -= height;\n          }\n\n          // Show the crop box if is hidden\n          if (!this.isCropped) {\n            this.$cropBox.removeClass(CLASS_HIDDEN);\n            this.isCropped = true;\n\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n\n          break;\n\n        // No default\n      }\n\n      if (renderable) {\n        cropBox.width = width;\n        cropBox.height = height;\n        cropBox.left = left;\n        cropBox.top = top;\n        this.action = action;\n\n        this.renderCropBox();\n      }\n\n      // Override\n      this.startX = this.endX;\n      this.startY = this.endY;\n    },\n\n    // Show the crop box manually\n    crop: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      if (!this.isCropped) {\n        this.isCropped = true;\n        this.limitCropBox(true, true);\n\n        if (this.options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n\n        this.$cropBox.removeClass(CLASS_HIDDEN);\n      }\n\n      this.setCropBoxData(this.initialCropBox);\n    },\n\n    // Reset the image and crop box to their initial states\n    reset: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      this.image = $.extend({}, this.initialImage);\n      this.canvas = $.extend({}, this.initialCanvas);\n      this.cropBox = $.extend({}, this.initialCropBox);\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    // Clear the crop box\n    clear: function () {\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      $.extend(this.cropBox, {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      });\n\n      this.isCropped = false;\n      this.renderCropBox();\n\n      this.limitCanvas(true, true);\n\n      // Render canvas after crop box rendered\n      this.renderCanvas();\n\n      this.$dragBox.removeClass(CLASS_MODAL);\n      this.$cropBox.addClass(CLASS_HIDDEN);\n    },\n\n    /**\n     * Replace the image's src and rebuild the cropper\n     *\n     * @param {String} url\n     * @param {Boolean} onlyColorChanged (optional)\n     */\n    replace: function (url, onlyColorChanged) {\n      if (!this.isDisabled && url) {\n        if (this.isImg) {\n          this.$element.attr('src', url);\n        }\n\n        if (onlyColorChanged) {\n          this.url = url;\n          this.$clone.attr('src', url);\n\n          if (this.isBuilt) {\n            this.$preview.find('img').add(this.$clone2).attr('src', url);\n          }\n        } else {\n          if (this.isImg) {\n            this.isReplaced = true;\n          }\n\n          // Clear previous data\n          this.options.data = null;\n          this.load(url);\n        }\n      }\n    },\n\n    // Enable (unfreeze) the cropper\n    enable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = false;\n        this.$cropper.removeClass(CLASS_DISABLED);\n      }\n    },\n\n    // Disable (freeze) the cropper\n    disable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = true;\n        this.$cropper.addClass(CLASS_DISABLED);\n      }\n    },\n\n    // Destroy the cropper and remove the instance from the image\n    destroy: function () {\n      var $this = this.$element;\n\n      if (this.isLoaded) {\n        if (this.isImg && this.isReplaced) {\n          $this.attr('src', this.originalUrl);\n        }\n\n        this.unbuild();\n        $this.removeClass(CLASS_HIDDEN);\n      } else {\n        if (this.isImg) {\n          $this.off(EVENT_LOAD, this.start);\n        } else if (this.$clone) {\n          this.$clone.remove();\n        }\n      }\n\n      $this.removeData(NAMESPACE);\n    },\n\n    /**\n     * Move the canvas with relative offsets\n     *\n     * @param {Number} offsetX\n     * @param {Number} offsetY (optional)\n     */\n    move: function (offsetX, offsetY) {\n      var canvas = this.canvas;\n\n      this.moveTo(\n        isUndefined(offsetX) ? offsetX : canvas.left + num(offsetX),\n        isUndefined(offsetY) ? offsetY : canvas.top + num(offsetY)\n      );\n    },\n\n    /**\n     * Move the canvas to an absolute point\n     *\n     * @param {Number} x\n     * @param {Number} y (optional)\n     */\n    moveTo: function (x, y) {\n      var canvas = this.canvas;\n      var isChanged = false;\n\n      // If \"y\" is not present, its default value is \"x\"\n      if (isUndefined(y)) {\n        y = x;\n      }\n\n      x = num(x);\n      y = num(y);\n\n      if (this.isBuilt && !this.isDisabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvas.left = x;\n          isChanged = true;\n        }\n\n        if (isNumber(y)) {\n          canvas.top = y;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderCanvas(true);\n        }\n      }\n    },\n\n    /**\n     * Zoom the canvas with a relative ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoom: function (ratio, _event) {\n      var canvas = this.canvas;\n\n      ratio = num(ratio);\n\n      if (ratio < 0) {\n        ratio =  1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n\n      this.zoomTo(canvas.width * ratio / canvas.naturalWidth, _event);\n    },\n\n    /**\n     * Zoom the canvas to an absolute ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoomTo: function (ratio, _event) {\n      var options = this.options;\n      var canvas = this.canvas;\n      var width = canvas.width;\n      var height = canvas.height;\n      var naturalWidth = canvas.naturalWidth;\n      var naturalHeight = canvas.naturalHeight;\n      var originalEvent;\n      var newWidth;\n      var newHeight;\n      var offset;\n      var center;\n\n      ratio = num(ratio);\n\n      if (ratio >= 0 && this.isBuilt && !this.isDisabled && options.zoomable) {\n        newWidth = naturalWidth * ratio;\n        newHeight = naturalHeight * ratio;\n\n        if (_event) {\n          originalEvent = _event.originalEvent;\n        }\n\n        if (this.trigger(EVENT_ZOOM, {\n          originalEvent: originalEvent,\n          oldRatio: width / naturalWidth,\n          ratio: newWidth / naturalWidth\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        if (originalEvent) {\n          offset = this.$cropper.offset();\n          center = originalEvent.touches ? getTouchesCenter(originalEvent.touches) : {\n            pageX: _event.pageX || originalEvent.pageX || 0,\n            pageY: _event.pageY || originalEvent.pageY || 0\n          };\n\n          // Zoom from the triggering point of the event\n          canvas.left -= (newWidth - width) * (\n            ((center.pageX - offset.left) - canvas.left) / width\n          );\n          canvas.top -= (newHeight - height) * (\n            ((center.pageY - offset.top) - canvas.top) / height\n          );\n        } else {\n\n          // Zoom from the center of the canvas\n          canvas.left -= (newWidth - width) / 2;\n          canvas.top -= (newHeight - height) / 2;\n        }\n\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Rotate the canvas with a relative degree\n     *\n     * @param {Number} degree\n     */\n    rotate: function (degree) {\n      this.rotateTo((this.image.rotate || 0) + num(degree));\n    },\n\n    /**\n     * Rotate the canvas to an absolute degree\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()\n     *\n     * @param {Number} degree\n     */\n    rotateTo: function (degree) {\n      degree = num(degree);\n\n      if (isNumber(degree) && this.isBuilt && !this.isDisabled && this.options.rotatable) {\n        this.image.rotate = degree % 360;\n        this.isRotated = true;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Scale the image\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()\n     *\n     * @param {Number} scaleX\n     * @param {Number} scaleY (optional)\n     */\n    scale: function (scaleX, scaleY) {\n      var image = this.image;\n      var isChanged = false;\n\n      // If \"scaleY\" is not present, its default value is \"scaleX\"\n      if (isUndefined(scaleY)) {\n        scaleY = scaleX;\n      }\n\n      scaleX = num(scaleX);\n      scaleY = num(scaleY);\n\n      if (this.isBuilt && !this.isDisabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          image.scaleX = scaleX;\n          isChanged = true;\n        }\n\n        if (isNumber(scaleY)) {\n          image.scaleY = scaleY;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderImage(true);\n        }\n      }\n    },\n\n    /**\n     * Scale the abscissa of the image\n     *\n     * @param {Number} scaleX\n     */\n    scaleX: function (scaleX) {\n      var scaleY = this.image.scaleY;\n\n      this.scale(scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n\n    /**\n     * Scale the ordinate of the image\n     *\n     * @param {Number} scaleY\n     */\n    scaleY: function (scaleY) {\n      var scaleX = this.image.scaleX;\n\n      this.scale(isNumber(scaleX) ? scaleX : 1, scaleY);\n    },\n\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     *\n     * @param {Boolean} isRounded (optional)\n     * @return {Object} data\n     */\n    getData: function (isRounded) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var ratio;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          x: cropBox.left - canvas.left,\n          y: cropBox.top - canvas.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n\n        ratio = image.width / image.naturalWidth;\n\n        $.each(data, function (i, n) {\n          n = n / ratio;\n          data[i] = isRounded ? round(n) : n;\n        });\n\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (options.rotatable) {\n        data.rotate = image.rotate || 0;\n      }\n\n      if (options.scalable) {\n        data.scaleX = image.scaleX || 1;\n        data.scaleY = image.scaleY || 1;\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the cropped area position and size with new data\n     *\n     * @param {Object} data\n     */\n    setData: function (data) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBoxData = {};\n      var isRotated;\n      var isScaled;\n      var ratio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== image.rotate) {\n            image.rotate = data.rotate;\n            this.isRotated = isRotated = true;\n          }\n        }\n\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== image.scaleX) {\n            image.scaleX = data.scaleX;\n            isScaled = true;\n          }\n\n          if (isNumber(data.scaleY) && data.scaleY !== image.scaleY) {\n            image.scaleY = data.scaleY;\n            isScaled = true;\n          }\n        }\n\n        if (isRotated) {\n          this.renderCanvas();\n        } else if (isScaled) {\n          this.renderImage();\n        }\n\n        ratio = image.width / image.naturalWidth;\n\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvas.left;\n        }\n\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvas.top;\n        }\n\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n\n        this.setCropBoxData(cropBoxData);\n      }\n    },\n\n    /**\n     * Get the container size data\n     *\n     * @return {Object} data\n     */\n    getContainerData: function () {\n      return this.isBuilt ? this.container : {};\n    },\n\n    /**\n     * Get the image position and size data\n     *\n     * @return {Object} data\n     */\n    getImageData: function () {\n      return this.isLoaded ? this.image : {};\n    },\n\n    /**\n     * Get the canvas position and size data\n     *\n     * @return {Object} data\n     */\n    getCanvasData: function () {\n      var canvas = this.canvas;\n      var data = {};\n\n      if (this.isBuilt) {\n        $.each([\n          'left',\n          'top',\n          'width',\n          'height',\n          'naturalWidth',\n          'naturalHeight'\n        ], function (i, n) {\n          data[n] = canvas[n];\n        });\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the canvas position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCanvasData: function (data) {\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvas.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          canvas.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          canvas.width = data.width;\n          canvas.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvas.height = data.height;\n          canvas.width = data.height * aspectRatio;\n        }\n\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Get the crop box position and size data\n     *\n     * @return {Object} data\n     */\n    getCropBoxData: function () {\n      var cropBox = this.cropBox;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          left: cropBox.left,\n          top: cropBox.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n      }\n\n      return data || {};\n    },\n\n    /**\n     * Set the crop box position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCropBoxData: function (data) {\n      var cropBox = this.cropBox;\n      var aspectRatio = this.options.aspectRatio;\n      var isWidthChanged;\n      var isHeightChanged;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && this.isCropped && !this.isDisabled && $.isPlainObject(data)) {\n\n        if (isNumber(data.left)) {\n          cropBox.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          cropBox.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          isWidthChanged = true;\n          cropBox.width = data.width;\n        }\n\n        if (isNumber(data.height)) {\n          isHeightChanged = true;\n          cropBox.height = data.height;\n        }\n\n        if (aspectRatio) {\n          if (isWidthChanged) {\n            cropBox.height = cropBox.width / aspectRatio;\n          } else if (isHeightChanged) {\n            cropBox.width = cropBox.height * aspectRatio;\n          }\n        }\n\n        this.renderCropBox();\n      }\n    },\n\n    /**\n     * Get a canvas drawn the cropped image\n     *\n     * @param {Object} options (optional)\n     * @return {HTMLCanvasElement} canvas\n     */\n    getCroppedCanvas: function (options) {\n      var originalWidth;\n      var originalHeight;\n      var canvasWidth;\n      var canvasHeight;\n      var scaledWidth;\n      var scaledHeight;\n      var scaledRatio;\n      var aspectRatio;\n      var canvas;\n      var context;\n      var data;\n\n      if (!this.isBuilt || !this.isCropped || !SUPPORT_CANVAS) {\n        return;\n      }\n\n      if (!$.isPlainObject(options)) {\n        options = {};\n      }\n\n      data = this.getData();\n      originalWidth = data.width;\n      originalHeight = data.height;\n      aspectRatio = originalWidth / originalHeight;\n\n      if ($.isPlainObject(options)) {\n        scaledWidth = options.width;\n        scaledHeight = options.height;\n\n        if (scaledWidth) {\n          scaledHeight = scaledWidth / aspectRatio;\n          scaledRatio = scaledWidth / originalWidth;\n        } else if (scaledHeight) {\n          scaledWidth = scaledHeight * aspectRatio;\n          scaledRatio = scaledHeight / originalHeight;\n        }\n      }\n\n      // The canvas element will use `Math.floor` on a float number, so floor first\n      canvasWidth = floor(scaledWidth || originalWidth);\n      canvasHeight = floor(scaledHeight || originalHeight);\n\n      canvas = $('<canvas>')[0];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      context = canvas.getContext('2d');\n\n      if (options.fillColor) {\n        context.fillStyle = options.fillColor;\n        context.fillRect(0, 0, canvasWidth, canvasHeight);\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n      context.drawImage.apply(context, (function () {\n        var source = getSourceCanvas(this.$clone[0], this.image);\n        var sourceWidth = source.width;\n        var sourceHeight = source.height;\n        var canvas = this.canvas;\n        var params = [source];\n\n        // Source canvas\n        var srcX = data.x + canvas.naturalWidth * (abs(data.scaleX || 1) - 1) / 2;\n        var srcY = data.y + canvas.naturalHeight * (abs(data.scaleY || 1) - 1) / 2;\n        var srcWidth;\n        var srcHeight;\n\n        // Destination canvas\n        var dstX;\n        var dstY;\n        var dstWidth;\n        var dstHeight;\n\n        if (srcX <= -originalWidth || srcX > sourceWidth) {\n          srcX = srcWidth = dstX = dstWidth = 0;\n        } else if (srcX <= 0) {\n          dstX = -srcX;\n          srcX = 0;\n          srcWidth = dstWidth = min(sourceWidth, originalWidth + srcX);\n        } else if (srcX <= sourceWidth) {\n          dstX = 0;\n          srcWidth = dstWidth = min(originalWidth, sourceWidth - srcX);\n        }\n\n        if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {\n          srcY = srcHeight = dstY = dstHeight = 0;\n        } else if (srcY <= 0) {\n          dstY = -srcY;\n          srcY = 0;\n          srcHeight = dstHeight = min(sourceHeight, originalHeight + srcY);\n        } else if (srcY <= sourceHeight) {\n          dstY = 0;\n          srcHeight = dstHeight = min(originalHeight, sourceHeight - srcY);\n        }\n\n        // All the numerical parameters should be integer for `drawImage` (#476)\n        params.push(floor(srcX), floor(srcY), floor(srcWidth), floor(srcHeight));\n\n        // Scale destination sizes\n        if (scaledRatio) {\n          dstX *= scaledRatio;\n          dstY *= scaledRatio;\n          dstWidth *= scaledRatio;\n          dstHeight *= scaledRatio;\n        }\n\n        // Avoid \"IndexSizeError\" in IE and Firefox\n        if (dstWidth > 0 && dstHeight > 0) {\n          params.push(floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n        }\n\n        return params;\n      }).call(this));\n\n      return canvas;\n    },\n\n    /**\n     * Change the aspect ratio of the crop box\n     *\n     * @param {Number} aspectRatio\n     */\n    setAspectRatio: function (aspectRatio) {\n      var options = this.options;\n\n      if (!this.isDisabled && !isUndefined(aspectRatio)) {\n\n        // 0 -> NaN\n        options.aspectRatio = max(0, aspectRatio) || NaN;\n\n        if (this.isBuilt) {\n          this.initCropBox();\n\n          if (this.isCropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n    },\n\n    /**\n     * Change the drag mode\n     *\n     * @param {String} mode (optional)\n     */\n    setDragMode: function (mode) {\n      var options = this.options;\n      var croppable;\n      var movable;\n\n      if (this.isLoaded && !this.isDisabled) {\n        croppable = mode === ACTION_CROP;\n        movable = options.movable && mode === ACTION_MOVE;\n        mode = (croppable || movable) ? mode : ACTION_NONE;\n\n        this.$dragBox.\n          data(DATA_ACTION, mode).\n          toggleClass(CLASS_CROP, croppable).\n          toggleClass(CLASS_MOVE, movable);\n\n        if (!options.cropBoxMovable) {\n\n          // Sync drag mode to crop box when it is not movable(#300)\n          this.$face.\n            data(DATA_ACTION, mode).\n            toggleClass(CLASS_CROP, croppable).\n            toggleClass(CLASS_MOVE, movable);\n        }\n      }\n    }\n  };\n\n  Cropper.DEFAULTS = {\n\n    // Define the view mode of the cropper\n    viewMode: 0, // 0, 1, 2, 3\n\n    // Define the dragging mode of the cropper\n    dragMode: 'crop', // 'crop', 'move' or 'none'\n\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n\n    // An object with the previous cropping result data\n    data: null,\n\n    // A jQuery selector for adding extra containers to preview\n    preview: '',\n\n    // Re-render the cropper when resize the window\n    responsive: true,\n\n    // Restore the cropped area after resize the window\n    restore: true,\n\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n\n    // Show the black modal\n    modal: true,\n\n    // Show the dashed lines for guiding\n    guides: true,\n\n    // Show the center indicator for guiding\n    center: true,\n\n    // Show the white modal to highlight the crop box\n    highlight: true,\n\n    // Show the grid background\n    background: true,\n\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n\n    // Enable to move the image\n    movable: true,\n\n    // Enable to rotate the image\n    rotatable: true,\n\n    // Enable to scale the image\n    scalable: true,\n\n    // Enable to zoom the image\n    zoomable: true,\n\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n\n    // Enable to move the crop box\n    cropBoxMovable: true,\n\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: 200,\n    minContainerHeight: 100,\n\n    // Shortcuts of events\n    build: null,\n    built: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n\n  Cropper.setDefaults = function (options) {\n    $.extend(Cropper.DEFAULTS, options);\n  };\n\n  Cropper.TEMPLATE = (\n    '<div class=\"cropper-container\">' +\n      '<div class=\"cropper-wrap-box\">' +\n        '<div class=\"cropper-canvas\"></div>' +\n      '</div>' +\n      '<div class=\"cropper-drag-box\"></div>' +\n      '<div class=\"cropper-crop-box\">' +\n        '<span class=\"cropper-view-box\"></span>' +\n        '<span class=\"cropper-dashed dashed-h\"></span>' +\n        '<span class=\"cropper-dashed dashed-v\"></span>' +\n        '<span class=\"cropper-center\"></span>' +\n        '<span class=\"cropper-face\"></span>' +\n        '<span class=\"cropper-line line-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-line line-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-line line-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-line line-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-point point-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-point point-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-point point-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-ne\" data-action=\"ne\"></span>' +\n        '<span class=\"cropper-point point-nw\" data-action=\"nw\"></span>' +\n        '<span class=\"cropper-point point-sw\" data-action=\"sw\"></span>' +\n        '<span class=\"cropper-point point-se\" data-action=\"se\"></span>' +\n      '</div>' +\n    '</div>'\n  );\n\n  // Save the other cropper\n  Cropper.other = $.fn.cropper;\n\n  // Register as jQuery plugin\n  $.fn.cropper = function (option) {\n    var args = toArray(arguments, 1);\n    var result;\n\n    this.each(function () {\n      var $this = $(this);\n      var data = $this.data(NAMESPACE);\n      var options;\n      var fn;\n\n      if (!data) {\n        if (/destroy/.test(option)) {\n          return;\n        }\n\n        options = $.extend({}, $this.data(), $.isPlainObject(option) && option);\n        $this.data(NAMESPACE, (data = new Cropper(this, options)));\n      }\n\n      if (typeof option === 'string' && $.isFunction(fn = data[option])) {\n        result = fn.apply(data, args);\n      }\n    });\n\n    return isUndefined(result) ? this : result;\n  };\n\n  $.fn.cropper.Constructor = Cropper;\n  $.fn.cropper.setDefaults = Cropper.setDefaults;\n\n  // No conflict\n  $.fn.cropper.noConflict = function () {\n    $.fn.cropper = Cropper.other;\n    return this;\n  };\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /var/cache/omnibus/src/gitlab-rails/vendor/assets/javascripts/cropper.js\n// module id = aX1M\n// module chunks = 23","/* eslint-disable comma-dangle, no-unused-vars, class-methods-use-this, quotes, consistent-return, func-names, prefer-arrow-callback, space-before-function-paren, max-len */\n/* global Flash */\n\n((global) => {\n  class Profile {\n    constructor({ form } = {}) {\n      this.onSubmitForm = this.onSubmitForm.bind(this);\n      this.form = form || $('.edit-user');\n      this.bindEvents();\n      this.initAvatarGlCrop();\n    }\n\n    initAvatarGlCrop() {\n      const cropOpts = {\n        filename: '.js-avatar-filename',\n        previewImage: '.avatar-image .avatar',\n        modalCrop: '.modal-profile-crop',\n        pickImageEl: '.js-choose-user-avatar-button',\n        uploadImageBtn: '.js-upload-user-avatar',\n        modalCropImg: '.modal-profile-crop-image'\n      };\n      this.avatarGlCrop = $('.js-user-avatar-input').glCrop(cropOpts).data('glcrop');\n    }\n\n    bindEvents() {\n      $('.js-preferences-form').on('change.preference', 'input[type=radio]', this.submitForm);\n      $('#user_notification_email').on('change', this.submitForm);\n      $('#user_notified_of_own_activity').on('change', this.submitForm);\n      $('.update-username').on('ajax:before', this.beforeUpdateUsername);\n      $('.update-username').on('ajax:complete', this.afterUpdateUsername);\n      $('.update-notifications').on('ajax:success', this.onUpdateNotifs);\n      this.form.on('submit', this.onSubmitForm);\n    }\n\n    submitForm() {\n      return $(this).parents('form').submit();\n    }\n\n    onSubmitForm(e) {\n      e.preventDefault();\n      return this.saveForm();\n    }\n\n    beforeUpdateUsername() {\n      $('.loading-username', this).removeClass('hidden');\n    }\n\n    afterUpdateUsername() {\n      $('.loading-username', this).addClass('hidden');\n      $('button[type=submit]', this).enable();\n    }\n\n    onUpdateNotifs(e, data) {\n      return data.saved ?\n        new Flash(\"Notification settings saved\", \"notice\") :\n        new Flash(\"Failed to save new settings\", \"alert\");\n    }\n\n    saveForm() {\n      const self = this;\n      const formData = new FormData(this.form[0]);\n      const avatarBlob = this.avatarGlCrop.getBlob();\n\n      if (avatarBlob != null) {\n        formData.append('user[avatar]', avatarBlob, 'avatar.png');\n      }\n\n      return $.ajax({\n        url: this.form.attr('action'),\n        type: this.form.attr('method'),\n        data: formData,\n        dataType: \"json\",\n        processData: false,\n        contentType: false,\n        success: response => new Flash(response.message, 'notice'),\n        error: jqXHR => new Flash(jqXHR.responseJSON.message, 'alert'),\n        complete: () => {\n          window.scrollTo(0, 0);\n          // Enable submit button after requests ends\n          return self.form.find(':input[disabled]').enable();\n        }\n      });\n    }\n  }\n\n  $(function() {\n    $(document).on('input.ssh_key', '#key_key', function() {\n      const $title = $('#key_title');\n      const comment = $(this).val().match(/^\\S+ \\S+ (.+)\\n?$/);\n\n      // Extract the SSH Key title from its comment\n      if (comment && comment.length > 1) {\n        return $title.val(comment[1]).change();\n      }\n    });\n    if (global.utils.getPagePath() === 'profiles') {\n      return new Profile();\n    }\n  });\n})(window.gl || (window.gl = {}));\n\n\n\n// WEBPACK FOOTER //\n// ./profile/profile.js"],"sourceRoot":""}